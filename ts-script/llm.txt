---
sidebar_position: 3
title: Initialize the Client
description: Configure the Nitrolite client to access state channel functionality.
keywords: [erc7824, nitrolite, client, initialization, configuration]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Initialize the Client

The NitroliteClient is the central entry point for interacting with state channels. This guide explains how to initialize and configure the client properly for your application.

## Understanding Key Components

Before we dive into initialization, it's important to understand the three key components required for Nitrolite:

1. **Public Client**: Used for reading blockchain data and state.
2. **Wallet Client**: Used for on-chain transactions like depositing funds, creating channels, etc.
3. **State Wallet Client**: Used for off-chain operations within state channels, primarily for signing messages.

## Why Separate Wallets?

Nitrolite uses separate wallet clients for on-chain and off-chain operations for several important reasons:

- **Security**: Keeps your main wallet's key separate from state channel operations
- **Performance**: Off-chain operations need a more lightweight and faster signing mechanism
- **User Experience**: Allows state channel operations without requiring wallet confirmation for every message
- **Persistence**: The state wallet needs to be accessible across sessions without requiring frequent user approval

## The EIP-191 Prefix Issue

A critical detail when implementing the state wallet is handling message signing correctly:

- **Standard wallets** (like MetaMask) automatically add an EIP-191 prefix to messages (`"\x19Ethereum Signed Message:\n" + message.length + message`)
- **State channel protocols** often require signing raw messages WITHOUT this prefix for consensus compatibility
- **Nitrolite requires** direct signing of raw message bytes for correct off-chain state validation

This is why we need to use a custom signing implementation with `wallet.signingKey.sign(raw)` rather than the standard `signMessage` method. Using the wrong signing method will cause channel operations to fail.

## Basic Client Initialization

Here's a basic example of initializing the Nitrolite client using the Sepolia testnet:

```javascript
import { NitroliteClient } from '@erc7824/nitrolite';
import { createPublicClient, createWalletClient, custom, http } from 'viem';
import { generatePrivateKey, privateKeyToAccount } from 'viem/accounts';
import { sepolia } from 'viem/chains';
import { ethers } from 'ethers';

// Step 1: Set up configuration
async function initializeNitrolite() {
  try {
    // Contract addresses on Sepolia
    const contractAddresses = {
      custody: '0xYourCustodyContractAddress',
      adjudicator: '0xYourAdjudicatorContractAddress',
      guestAddress: '0xDefaultGuestAddress',
      tokenAddress: '0xYourTokenAddress',
    };

    // Step 2: Create a public client for reading blockchain data
    const publicClient = createPublicClient({
      chain: sepolia,
      transport: http('https://rpc.sepolia.org'),
    });

    // Step 3: Connect to the user's wallet for on-chain transactions
    // Check if MetaMask is available
    if (!window.ethereum) {
      throw new Error('MetaMask is not installed. Please install MetaMask to use this application.');
    }

    // Request account access
    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
    const address = accounts[0];

    // Create the wallet client using the Ethereum provider
    const walletClient = createWalletClient({
      chain: sepolia,
      transport: custom(window.ethereum),
      account: address,
    });

    // Step 4: Create or retrieve a state wallet for off-chain operations
    // This wallet is used for signing state channel messages
    let stateWalletPrivateKey = localStorage.getItem('nitrolite_state_wallet_key');
    
    // Generate a new private key if one doesn't exist
    if (!stateWalletPrivateKey) {
      stateWalletPrivateKey = generatePrivateKey();
      localStorage.setItem('nitrolite_state_wallet_key', stateWalletPrivateKey);
    }
    
    // Create the state wallet account
    const stateWalletAccount = privateKeyToAccount(stateWalletPrivateKey);
    
    // Create a state wallet client with the signing capabilities Nitrolite needs
    // IMPORTANT: We need to sign raw messages WITHOUT the EIP-191 prefix
    const stateWalletClient = {
      account: {
        address: stateWalletAccount.address,
      },
      signMessage: async ({ message: { raw } }) => {
        // Using ethers.js to sign the raw message without EIP-191 prefix
        const wallet = new ethers.Wallet(stateWalletPrivateKey);
        const { serialized: signature } = wallet.signingKey.sign(raw);
        return signature;
      },
    };

    // Step 5: Create the Nitrolite client
    const client = new NitroliteClient({
      publicClient,
      walletClient,
      stateWalletClient,
      account: walletClient.account,
      chainId: sepolia.id,
      challengeDuration: 86400, // 24 hours in seconds
      addresses: contractAddresses,
    });

    console.log('Nitrolite client initialized successfully!');
    return client;
  } catch (error) {
    console.error('Failed to initialize Nitrolite client:', error);
    throw error;
  }
}
```

## State Wallet Storage Strategies

You can implement different storage strategies for the state wallet private key:

```javascript
// Option 1: Local Storage (simplest, but less secure)
function getStateWalletFromLocalStorage() {
  const key = localStorage.getItem('nitrolite_state_wallet_key');
  if (!key) {
    const newKey = generatePrivateKey();
    localStorage.setItem('nitrolite_state_wallet_key', newKey);
    return newKey;
  }
  return key;
}

// Option 2: Encrypted Storage
function getStateWalletFromEncryptedStorage(userPassword) {
  const encryptedKey = localStorage.getItem('nitrolite_encrypted_key');
  if (!encryptedKey) {
    const newKey = generatePrivateKey();
    const encryptedNewKey = encryptWithPassword(newKey, userPassword);
    localStorage.setItem('nitrolite_encrypted_key', encryptedNewKey);
    return newKey;
  }
  return decryptWithPassword(encryptedKey, userPassword);
}

// Helper functions for encryption (implementation depends on your encryption library)
function encryptWithPassword(data, password) {
  // Implement encryption logic
}

function decryptWithPassword(encryptedData, password) {
  // Implement decryption logic
}
```

## Integrating with Different Web Frameworks

While the core initialization logic remains the same, here's how you can adapt it for different frameworks:

<Tabs>
  <TabItem value="react" label="React">

```javascript
import { useState, useEffect } from 'react';

function useNitroliteClient() {
  const [client, setClient] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function init() {
      try {
        setLoading(true);
        const nitroliteClient = await initializeNitrolite();
        setClient(nitroliteClient);
        setError(null);
      } catch (err) {
        setError(err.message);
        setClient(null);
      } finally {
        setLoading(false);
      }
    }

    init();
  }, []);

  return { client, loading, error };
}
```

  </TabItem>
  <TabItem value="angular" label="Angular">

```typescript
// In an Angular service
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class NitroliteService {
  private clientSource = new BehaviorSubject<any>(null);
  private loadingSource = new BehaviorSubject<boolean>(true);
  private errorSource = new BehaviorSubject<string | null>(null);

  client$ = this.clientSource.asObservable();
  loading$ = this.loadingSource.asObservable();
  error$ = this.errorSource.asObservable();

  constructor() {
    this.initializeClient();
  }

  private async initializeClient() {
    try {
      this.loadingSource.next(true);
      const nitroliteClient = await initializeNitrolite();
      this.clientSource.next(nitroliteClient);
      this.errorSource.next(null);
    } catch (err) {
      this.errorSource.next(err.message);
      this.clientSource.next(null);
    } finally {
      this.loadingSource.next(false);
    }
  }
}

// In a component
import { Component, OnInit } from '@angular/core';
import { NitroliteService } from './nitrolite.service';

@Component({
  selector: 'app-nitrolite',
  template: `
    <div *ngIf="loading">Loading Nitrolite client...</div>
    <div *ngIf="error">Error: {{ error }}</div>
    <div *ngIf="client">Client initialized successfully!</div>
  `
})
export class NitroliteComponent implements OnInit {
  client: any;
  loading = true;
  error: string | null = null;

  constructor(private nitroliteService: NitroliteService) {}

  ngOnInit() {
    this.nitroliteService.client$.subscribe(client => this.client = client);
    this.nitroliteService.loading$.subscribe(loading => this.loading = loading);
    this.nitroliteService.error$.subscribe(error => this.error = error);
  }
}
```

  </TabItem>
  <TabItem value="vue" label="Vue">

```javascript
// In a Vue component
export default {
  data() {
    return {
      client: null,
      loading: true,
      error: null
    }
  },
  async mounted() {
    try {
      this.loading = true;
      this.client = await initializeNitrolite();
      this.error = null;
    } catch (err) {
      this.error = err.message;
      this.client = null;
    } finally {
      this.loading = false;
    }
  }
}
```

  </TabItem>
  <TabItem value="svelte" label="Svelte">

```javascript
<script>
  import { onMount } from 'svelte';
  
  let client = null;
  let loading = true;
  let error = null;
  
  onMount(async () => {
    try {
      loading = true;
      client = await initializeNitrolite();
      error = null;
    } catch (err) {
      error = err.message;
      client = null;
    } finally {
      loading = false;
    }
  });
</script>

{#if loading}
  <p>Loading Nitrolite client...</p>
{:else if error}
  <p class="error">Error: {error}</p>
{:else}
  <p>Nitrolite client initialized successfully!</p>
{/if}
```

  </TabItem>
  <TabItem value="nodejs" label="Node.js">

```javascript
const { NitroliteClient } = require('@erc7824/nitrolite');
const { createPublicClient, createWalletClient, http } = require('viem');
const { privateKeyToAccount } = require('viem/accounts');
const { sepolia } = require('viem/chains');
const { ethers } = require('ethers');
const fs = require('fs');

async function initializeNodeClient() {
  try {
    console.log('Initializing Nitrolite client...');
    
    // Contract addresses on Sepolia
    const contractAddresses = {
      custody: '0xYourCustodyContractAddress',
      adjudicator: '0xYourAdjudicatorContractAddress',
      guestAddress: '0xDefaultGuestAddress',
      tokenAddress: '0xYourTokenAddress',
    };

    // Create a public client for reading blockchain data
    const publicClient = createPublicClient({
      chain: sepolia,
      transport: http('https://rpc.sepolia.org'),
    });

    // Load or create wallet for on-chain transactions
    let onChainPrivateKey;
    const keyPath = './keys/on-chain-key.json';
    
    try {
      if (fs.existsSync(keyPath)) {
        const keyData = JSON.parse(fs.readFileSync(keyPath, 'utf8'));
        onChainPrivateKey = keyData.privateKey;
      } else {
        // Generate new key for demo purposes (in production, use a secure key)
        onChainPrivateKey = ethers.Wallet.createRandom().privateKey;
        fs.mkdirSync('./keys', { recursive: true });
        fs.writeFileSync(keyPath, JSON.stringify({ privateKey: onChainPrivateKey }));
      }
    } catch (error) {
      console.error('Failed to load or create on-chain wallet:', error);
      throw error;
    }
    
    // Create wallet account
    const account = privateKeyToAccount(onChainPrivateKey);
    
    // Create wallet client
    const walletClient = {
      account: {
        address: account.address,
      },
      sendTransaction: async (tx) => {
        const wallet = new ethers.Wallet(onChainPrivateKey, 
          new ethers.providers.JsonRpcProvider('https://rpc.sepolia.org'));
        return wallet.sendTransaction(tx);
      }
    };
    
    // Load or create state wallet for off-chain operations
    let stateWalletPrivateKey;
    const stateKeyPath = './keys/state-wallet-key.json';
    
    try {
      if (fs.existsSync(stateKeyPath)) {
        const keyData = JSON.parse(fs.readFileSync(stateKeyPath, 'utf8'));
        stateWalletPrivateKey = keyData.privateKey;
      } else {
        stateWalletPrivateKey = ethers.Wallet.createRandom().privateKey;
        fs.writeFileSync(stateKeyPath, JSON.stringify({ privateKey: stateWalletPrivateKey }));
      }
    } catch (error) {
      console.error('Failed to load or create state wallet:', error);
      throw error;
    }
    
    // Create state wallet with raw signing capability
    const stateWallet = new ethers.Wallet(stateWalletPrivateKey);
    const stateWalletClient = {
      account: {
        address: stateWallet.address,
      },
      signMessage: async ({ message: { raw } }) => {
        const { serialized: signature } = stateWallet.signingKey.sign(raw);
        return signature;
      }
    };
    
    // Create Nitrolite client
    const client = new NitroliteClient({
      publicClient,
      walletClient,
      stateWalletClient,
      account: walletClient.account,
      chainId: sepolia.id,
      challengeDuration: 86400,
      addresses: contractAddresses,
    });
    
    console.log('Nitrolite client initialized successfully!');
    return client;
  } catch (error) {
    console.error('Failed to initialize Nitrolite client:', error);
    throw error;
  }
}

// Run the initialization
initializeNodeClient()
  .then(client => {
    console.log('Client ready to use');
    // Start your application logic here
  })
  .catch(error => {
    console.error('Initialization failed:', error);
    process.exit(1);
  });
```

  </TabItem>
</Tabs>

## Next Steps

Once you've initialized the client, you can:

1. [Deposit funds and create a channel](deposit_and_create_channel)
2. [Connect to a ClearNode](connect_to_the_clearnode)
3. [Manage channel assets](balances)

For any issues with initialization, check the client's error events or console logs for detailed error messages.

---

---
sidebar_position: 4
title: Deposit And Create Channel
description: Fund your state channel with assets and establish a secure connection between participants.
keywords: [erc7824, nitrolite, deposit, state channel, create channel, funding, USDC]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Deposit And Create Channel

Creating a state channel involves depositing funds into a smart contract and establishing the channel parameters. This guide walks through the complete process of depositing USDC and creating a functional state channel.

## Understanding State Channels in Nitrolite

A state channel is a secure off-chain communication pathway between two participants:

1. **Your Application** (User/App Server): The initiating participant who will use the channel for your application
2. **ClearNode**: The counterparty that facilitates off-chain transaction processing and verification

In Nitrolite, state channels are created with the following properties:

- Channels require on-chain deposits (USDC tokens)
- All participants must agree to channel terms
- Channel creation requires gas fees
- Funds are locked in the contract until the channel is closed

> **Important**: Nitrolite only supports ERC20 tokens like USDC. Native tokens like ETH are not directly supported.

## Step 1: Prepare for Channel Creation

Before creating a channel, ensure that:

1. Your client is properly initialized and connected to a wallet
2. You have sufficient ETH for gas fees
3. You have USDC tokens to deposit into the channel
4. You have the ClearNode address that will act as your counterparty

```javascript
// Check USDC balance before proceeding
const usdcBalance = await client.getTokenBalance();
console.log('Available USDC balance:', usdcBalance);

// Define channel participants
const participants = [
  client.account.address, // Your address (from connected wallet)
  client.addresses.guestAddress, // ClearNode address (from client config)
];
```

## Step 2: Deposit USDC Tokens

Before creating a channel, you need to deposit USDC tokens to the custody contract:

<Tabs>
  <TabItem value="separate" label="One-Step Process">

```javascript
// Step 1: Approve USDC tokens for deposit
// Note: In Nitrolite, approval is handled automatically by the deposit function if needed
const depositAmount = 100000000n; // 100 USDC (with 6 decimals)

// Step 2: Deposit USDC into the custody contract
try {
  const depositTx = await client.deposit(depositAmount);
  console.log('Deposit transaction submitted:', depositTx);
  
  // The deposit function waits for transaction confirmation internally
  console.log('USDC tokens successfully deposited to custody contract');
} catch (error) {
  console.error('Deposit failed:', error.message);
}
```

  </TabItem>
  <TabItem value="manual" label="Manual Approval">

```javascript
// If you want more control over the approval process:
try {
  // 1. Check current allowance
  const currentAllowance = await client.getTokenAllowance();
  console.log('Current USDC allowance:', currentAllowance);
  
  // 2. Approve USDC if needed
  if (currentAllowance < depositAmount) {
    const approvalTx = await client.approveTokens(depositAmount);
    console.log('Approval transaction submitted:', approvalTx);
    // Wait for approval to be confirmed
    // (typically you would wait for the transaction to be mined)
  }
  
  // 3. Deposit USDC
  const depositTx = await client.deposit(depositAmount);
  console.log('Deposit transaction submitted:', depositTx);
} catch (error) {
  console.error('Approval or deposit failed:', error.message);
}
```

  </TabItem>
</Tabs>

## Step 3: Create the Channel

After depositing USDC, you can create a channel between your application and the ClearNode:

```javascript
// Define channel parameters
const channelParams = {
  participants: participants, // [your address, ClearNode address]
  amounts: [depositAmount, 0n], // Initial allocation (you: 100 USDC, ClearNode: 0)
  tokenAddress: client.addresses.tokenAddress, // USDC token address (from client config)
  challengePeriod: client.challengeDuration, // Use default from client config
  nonce: BigInt(Date.now()), // Unique channel identifier
};

try {
  // Create the channel
  const { channelId, initialState, txHash } = await client.createChannel(channelParams);
  
  console.log('Channel created with ID:', channelId);
  console.log('Initial state:', initialState);
  console.log('Transaction hash:', txHash);
} catch (error) {
  console.error('Channel creation failed:', error.message);
}
```

## Step 4: Verify Channel Creation

After creating the channel, verify that it exists and is properly funded:

```javascript
// Get the list of channels associated with your account
const myChannels = await client.getAccountChannels();
console.log('My channels:', myChannels);

// Get account information including deposits and locked amounts
const accountInfo = await client.getAccountInfo();
console.log('Account info:', accountInfo);
// This shows:
// - availableAmount: USDC available for withdrawal or new channels
// - channelCount: Number of active channels
```

## Combined Process: Deposit and Create Channel

Nitrolite provides a convenient method to perform both operations in a single call:

```javascript
// Deposit USDC and create channel in one operation
const depositAmount = 100000000n; // 100 USDC (6 decimals)

const channelParams = {
  participants: [
    client.account.address, // Your address (from connected wallet)
    client.addresses.guestAddress, // ClearNode address (from client config)
  ],
  amounts: [depositAmount, 0n], // Initial allocation
  tokenAddress: client.addresses.tokenAddress, // USDC token address
  challengePeriod: client.challengeDuration, // Use default from client config
  nonce: BigInt(Date.now()), // Unique channel identifier
};

try {
  const { 
    channelId, 
    initialState, 
    depositTxHash, 
    createChannelTxHash 
  } = await client.depositAndCreateChannel(depositAmount, channelParams);
  
  console.log('USDC deposited with transaction:', depositTxHash);
  console.log('Channel created with ID:', channelId);
  console.log('Channel creation transaction:', createChannelTxHash);
} catch (error) {
  console.error('Deposit and channel creation failed:', error.message);
}
```

## Channel Parameters Explained

When creating a channel, here's what each parameter means:

| Parameter | Description |
|-----------|-------------|
| `participants` | Array containing your address and the ClearNode address |
| `amounts` | Initial fund allocation for each participant (typically all funds start with you) |
| `tokenAddress` | Address of the USDC token contract (defined in client config) |
| `challengePeriod` | Time window (in seconds) for resolving disputes before settlement |
| `nonce` | Unique identifier to prevent replay attacks (typically current timestamp) |

## Best Practices

- **Fund Allocation**: Initially allocate all funds to your side for maximum flexibility
- **Challenge Period**: Use a reasonable period (e.g., 24 hours) to allow time for responding to challenges
- **Error Handling**: Implement proper error handling as deposit and channel creation may fail for various reasons
- **Gas Management**: Ensure you have enough ETH for gas fees, especially during network congestion
- **Transaction Monitoring**: Monitor transaction status, particularly for deposit approval

## Next Steps

After creating your channel, you can:

1. [Connect to a ClearNode](connect_to_the_clearnode) for off-chain messaging
2. [View channel assets](balances) to monitor your funds
3. [Create an application session](application_session) to start transacting

For advanced channel operations, see the [Resize Channel](resize_channel) guide.

---

---
sidebar_position: 5
title: Connect to the ClearNode
description: Establish connection with ClearNode for reliable off-chain transaction processing and verification.
keywords: [erc7824, nitrolite, clearnode, off-chain, validation, messaging, nitroliterpc, websocket]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Connect to the ClearNode

A ClearNode is a specialized service that facilitates off-chain communication, message relay, and state validation in the Nitrolite ecosystem. This guide explains how to establish and manage connections to a ClearNode using the NitroliteRPC protocol.

## What is a ClearNode?

A **[ClearNode](https://github.com/erc7824/clearnode)** is an implementation of a message broker for the Clearnet protocol. It serves as a critical infrastructure component in the Nitrolite ecosystem, providing several important functions in the state channel network:

- **Multi-Chain Support**: Connect to multiple EVM blockchains (Polygon, Celo, Base)
- **Off-Chain Payments**: Efficient payment channels for high-throughput transactions
- **Virtual Applications**: Create multi-participant applications
- **Quorum-Based Signatures**: Support for multi-signature schemes with weight-based quorums

## Understanding NitroliteRPC

NitroliteRPC is a utility in our SDK that standardizes message creation for communication with ClearNodes. It's not a full protocol implementation but rather a set of helper functions that ensure your application constructs properly formatted messages for ClearNode interaction.

Key functions of NitroliteRPC include:

- **Message Construction**: Creates properly formatted request messages
- **Signature Management**: Handles the cryptographic signing of messages
- **Standard Format Enforcement**: Ensures all messages follow the required format for ClearNode compatibility
- **Authentication Flow Helpers**: Simplifies the authentication process

Under the hood, NitroliteRPC provides functions that generate message objects with the correct structure, timestamps, and signature formatting so you don't have to build these messages manually when communicating with ClearNodes.

## Connecting to a ClearNode

After initializing your client and creating a channel, you need to establish a WebSocket connection to a ClearNode. It's important to understand that the Nitrolite SDK doesn't provide its own transport layer - you'll need to implement the WebSocket connection yourself using your preferred library.

<Tabs>
  <TabItem value="basic" label="WebSocket Connection">

```javascript
// Import your preferred WebSocket library
import WebSocket from 'ws'; // Node.js
// or use the browser's built-in WebSocket

// Create a WebSocket connection to the ClearNode
const ws = new WebSocket('wss://clearnode.example.com');

// Set up basic event handlers
ws.onopen = () => {
  console.log('WebSocket connection established');
  // Connection is open, can now proceed with authentication
};

ws.onmessage = (event) => {
  const message = JSON.parse(event.data);
  console.log('Received message:', message);
  // Process incoming messages
};

ws.onerror = (error) => {
  console.error('WebSocket error:', error);
};

ws.onclose = (event) => {
  console.log(`WebSocket closed: ${event.code} ${event.reason}`);
};
```

  </TabItem>
  <TabItem value="advanced" label="With Reconnection Logic">

```javascript
class ClearNodeConnection {
  constructor(url) {
    this.url = url;
    this.ws = null;
    this.isConnected = false;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.reconnectInterval = 3000; // ms
    this.messageHandlers = new Map();
  }
  
  // Register message handlers
  onMessage(type, handler) {
    this.messageHandlers.set(type, handler);
  }
  
  connect() {
    this.ws = new WebSocket(this.url);
    
    this.ws.onopen = this.handleOpen.bind(this);
    this.ws.onmessage = this.handleMessage.bind(this);
    this.ws.onerror = this.handleError.bind(this);
    this.ws.onclose = this.handleClose.bind(this);
  }
  
  handleOpen() {
    console.log(`Connected to ClearNode at ${this.url}`);
    this.isConnected = true;
    this.reconnectAttempts = 0;
    
    // Emit connected event
    this.emit('connected');
  }
  
  handleMessage(event) {
    try {
      const message = JSON.parse(event.data);
      
      // Determine message type (auth_challenge, auth_success, etc.)
      const messageType = message.res ? message.res[1] : 'unknown';
      
      // Emit specific message event
      this.emit('message', message);
      
      // Call specific handler if registered
      if (this.messageHandlers.has(messageType)) {
        this.messageHandlers.get(messageType)(message);
      }
    } catch (error) {
      console.error('Error handling message:', error);
    }
  }
  
  handleError(error) {
    console.error('WebSocket error:', error);
    this.emit('error', error);
  }
  
  handleClose(event) {
    this.isConnected = false;
    console.log(`WebSocket closed: ${event.code} ${event.reason}`);
    
    // Emit disconnected event
    this.emit('disconnected', event);
    
    // Attempt to reconnect
    this.attemptReconnect();
  }
  
  attemptReconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Maximum reconnection attempts reached');
      return;
    }
    
    this.reconnectAttempts++;
    const delay = this.reconnectInterval * Math.pow(2, this.reconnectAttempts - 1);
    
    console.log(`Attempting to reconnect in ${delay}ms (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
    
    setTimeout(() => {
      console.log('Reconnecting...');
      this.connect();
    }, delay);
  }
  
  send(message) {
    if (!this.isConnected) {
      console.error('Cannot send message: not connected');
      return false;
    }
    
    try {
      this.ws.send(typeof message === 'string' ? message : JSON.stringify(message));
      return true;
    } catch (error) {
      console.error('Error sending message:', error);
      return false;
    }
  }
  
  disconnect() {
    if (this.ws) {
      this.ws.close(1000, 'User initiated disconnect');
    }
  }
  
  // Simple event system
  #events = {};
  
  on(event, callback) {
    if (!this.#events[event]) this.#events[event] = [];
    this.#events[event].push(callback);
    return this;
  }
  
  off(event, callback) {
    if (!this.#events[event]) return this;
    if (!callback) {
      delete this.#events[event];
      return this;
    }
    this.#events[event] = this.#events[event].filter(cb => cb !== callback);
    return this;
  }
  
  emit(event, ...args) {
    if (!this.#events[event]) return false;
    this.#events[event].forEach(callback => callback(...args));
    return true;
  }
}

// Usage
const clearNodeConnection = new ClearNodeConnection('wss://clearnode.example.com');
clearNodeConnection.connect();

// Register event handlers
clearNodeConnection.on('connected', () => {
  console.log('Connection established, ready to authenticate');
});

// Later, when you're done
clearNodeConnection.disconnect();
```

  </TabItem>
</Tabs>

## Authentication Flow

When connecting to a ClearNode, you need to follow a specific authentication flow using the NitroliteRPC utility to create properly formatted and signed messages:

1. **Initial Connection**: The client establishes a WebSocket connection to the ClearNode's URL
2. **Auth Request**: The client sends an `auth_request` message with its identity information
3. **Challenge**: The ClearNode responds with an `auth_challenge` containing a random nonce
4. **Signature Verification**: The client signs the challenge using its state wallet and sends an `auth_verify` message
5. **Auth Result**: The ClearNode verifies the signature and responds with `auth_success` or `auth_failure`

This flow ensures that only authorized participants with valid signing keys can connect to the ClearNode and participate in channel operations.

<Tabs>
  <TabItem value="auth" label="Authentication Process">

```javascript
import { createAuthRequestMessage, createAuthVerifyMessage } from '@erc7824/nitrolite';
import { ethers } from 'ethers';

// Important: Custom message signer that correctly hashes the message with ethers.id
// This is crucial for proper ClearNode communication
const messageSigner = async (payload) => {
  try {
    // Convert the payload to a JSON string
    const message = JSON.stringify(payload);
    
    // Hash the message with ethers.id (keccak256 hash)
    const digestHex = ethers.id(message);
    
    // Convert the hash to bytes
    const messageBytes = ethers.getBytes(digestHex);
    
    // Sign the bytes with the wallet's signing key
    // Note: This uses the raw signing method, not the EIP-191 prefixed signing!
    const { serialized: signature } = client.stateWalletClient.wallet.signingKey.sign(messageBytes);
    
    return signature;
  } catch (error) {
    console.error("Error signing message:", error);
    throw error;
  }
};

// After WebSocket connection is established
ws.onopen = async () => {
  console.log('WebSocket connection established');
  
  // Step 1: Create and send auth_request
  const authRequestMsg = await createAuthRequestMessage(
    messageSigner, // Our custom message signer function
    client.stateWalletClient.account.address // Client address
  );
  
  ws.send(authRequestMsg);
};

// Handle incoming messages
ws.onmessage = async (event) => {
  try {
    const message = JSON.parse(event.data);
    
    // Step 2: Handle auth_challenge response
    if (message.res && message.res[1] === 'auth_challenge') {
      console.log('Received auth challenge');
      
      // Step 3: Create and send auth_verify with signed challenge
      const authVerifyMsg = await createAuthVerifyMessage(
        messageSigner, // Our custom message signer function
        message, // Raw challenge response from ClearNode
        client.stateWalletClient.account.address // Client address (same as in auth_request)
      );
      
      ws.send(authVerifyMsg);
    }
    // Step 4: Handle auth_success or auth_failure
    else if (message.res && message.res[1] === 'auth_success') {
      console.log('Authentication successful');
      // Now you can start using the channel
    }
    else if (message.res && message.res[1] === 'auth_failure') {
      console.error('Authentication failed:', message.res[2]);
    }
  } catch (error) {
    console.error('Error handling message:', error);
  }
};
```

  </TabItem>
  <TabItem value="challenge" label="Manual Challenge Handling">

```javascript
import { 
  createAuthRequestMessage, 
  createAuthVerifyMessageFromChallenge,
  createGetLedgerBalancesMessage,
  createGetConfigMessage 
} from '@erc7824/nitrolite';
import { ethers } from 'ethers';

// Create the proper message signer function
const messageSigner = async (payload) => {
  try {
    // Convert the payload to a JSON string
    const message = JSON.stringify(payload);
    
    // Hash the message with ethers.id (keccak256 hash)
    const digestHex = ethers.id(message);
    
    // Convert the hash to bytes
    const messageBytes = ethers.getBytes(digestHex);
    
    // Sign the bytes with the wallet's signing key
    const { serialized: signature } = client.stateWalletClient.wallet.signingKey.sign(messageBytes);
    
    return signature;
  } catch (error) {
    console.error("Error signing message:", error);
    throw error;
  }
};

// After connection is established, send auth request
ws.onopen = async () => {
  const authRequestMsg = await createAuthRequestMessage(
    messageSigner,
    client.stateWalletClient.account.address
  );
  ws.send(authRequestMsg);
};

// If you want to manually extract and handle the challenge
ws.onmessage = async (event) => {
  try {
    const message = JSON.parse(event.data);
    
    if (message.res && message.res[1] === 'auth_challenge') {
      // Extract the challenge manually from the response
      if (
        message.res[2] && 
        Array.isArray(message.res[2]) && 
        message.res[2][0] && 
        message.res[2][0].challenge_message
      ) {
        const challenge = message.res[2][0].challenge_message;
        
        // Create auth_verify with the explicitly provided challenge
        const authVerifyMsg = await createAuthVerifyMessageFromChallenge(
          messageSigner,
          client.stateWalletClient.account.address,
          challenge
        );
        
        ws.send(authVerifyMsg);
      } else {
        console.error('Malformed challenge response');
      }
    }
  } catch (error) {
    console.error('Error handling message:', error);
  }
};
```

  </TabItem>
</Tabs>

## Getting Channel Information

After authenticating with a ClearNode, you can request information about your channels. This is useful to verify your connection is working correctly and to retrieve channel data.

```javascript
import { createGetChannelsMessage } from '@erc7824/nitrolite';

// Example of using the function after authentication is complete
ws.addEventListener('message', async (event) => {
  const message = JSON.parse(event.data);
  
  // Check if this is a successful authentication message
  if (message.res && message.res[1] === 'auth_success') {
    console.log('Successfully authenticated, requesting channel information...');
    
    // Create a custom message signer function if you don't already have one
    const messageSigner = async (payload) => {
      // This is the same message signer function used in authentication
      const message = JSON.stringify(payload);
      const digestHex = ethers.id(message);
      const messageBytes = ethers.getBytes(digestHex);
      const { serialized: signature } = client.stateWalletClient.wallet.signingKey.sign(messageBytes);
      return signature;
    };
    
    // Request channel information using the built-in helper function
    const getChannelsMsg = await createGetChannelsMessage(
      messageSigner,
      client.stateWalletClient.account.address
    );
    
    ws.send(getChannelsMsg);
  }
  
  // Handle get_channels response
  if (message.res && message.res[1] === 'get_channels') {
    console.log('Received channels information:');
    const channelsList = message.res[2][0]; // Note the response format has changed
    
    if (channelsList && channelsList.length > 0) {
      channelsList.forEach((channel, index) => {
        console.log(`Channel ${index + 1}:`);
        console.log(`- Channel ID: ${channel.channel_id}`);
        console.log(`- Status: ${channel.status}`);
        console.log(`- Participant: ${channel.participant}`);
        console.log(`- Token: ${channel.token}`);
        console.log(`- Amount: ${channel.amount}`);
        console.log(`- Chain ID: ${channel.chain_id}`);
        console.log(`- Adjudicator: ${channel.adjudicator}`);
        console.log(`- Challenge: ${channel.challenge}`);
        console.log(`- Nonce: ${channel.nonce}`);
        console.log(`- Version: ${channel.version}`);
        console.log(`- Created: ${channel.created_at}`);
        console.log(`- Updated: ${channel.updated_at}`);
      });
    } else {
      console.log('No active channels found');
    }
  }
});
```

### Response Format

The response to a `get_channels` request includes detailed information about each channel:

```javascript
{
  "res": [1, "get_channels", [[  // Notice the nested array structure
    {
      "channel_id": "0xfedcba9876543210...",
      "participant": "0x1234567890abcdef...",
      "status": "open", // Can be "open", "closed", "settling", etc.
      "token": "0xeeee567890abcdef...", // ERC20 token address
      "amount": "100000", // Current channel balance
      "chain_id": 137, // Chain ID (e.g., 137 for Polygon)
      "adjudicator": "0xAdjudicatorContractAddress...", // Contract address
      "challenge": 86400, // Challenge period in seconds
      "nonce": 1,
      "version": 2,
      "created_at": "2023-05-01T12:00:00Z",
      "updated_at": "2023-05-01T12:30:00Z"
    }
  ]], 1619123456789],
  "sig": ["0xabcd1234..."]
}
```

## Framework-Specific Integration

Here are examples of integrating ClearNode WebSocket connections with various frameworks. Since the Nitrolite SDK doesn't provide its own transport layer, these examples show how to implement WebSocket connections and the NitroliteRPC message format in different frameworks.

<Tabs>
  <TabItem value="react" label="React">

```javascript
import { useState, useEffect, useCallback } from 'react';
import { ethers } from 'ethers';
import { 
  createAuthRequestMessage, 
  createAuthVerifyMessage,
  createGetChannelsMessage,
  createGetLedgerBalancesMessage,
  createGetConfigMessage,
  generateRequestId, 
  getCurrentTimestamp 
} from '@erc7824/nitrolite';

// Custom hook for ClearNode connection
function useClearNodeConnection(clearNodeUrl, stateWallet) {
  const [ws, setWs] = useState(null);
  const [connectionStatus, setConnectionStatus] = useState('disconnected');
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [error, setError] = useState(null);
  
  // Message signer function
  const messageSigner = useCallback(async (payload) => {
    if (!stateWallet) throw new Error('State wallet not available');
    
    try {
      const message = JSON.stringify(payload);
      const digestHex = ethers.id(message);
      const messageBytes = ethers.getBytes(digestHex);
      const { serialized: signature } = stateWallet.signingKey.sign(messageBytes);
      return signature;
    } catch (error) {
      console.error("Error signing message:", error);
      throw error;
    }
  }, [stateWallet]);
  
  // Create a signed request
  const createSignedRequest = useCallback(async (method, params = []) => {
    if (!stateWallet) throw new Error('State wallet not available');
    
    const requestId = generateRequestId();
    const timestamp = getCurrentTimestamp();
    const requestData = [requestId, method, params, timestamp];
    const request = { req: requestData };
    
    // Sign the request
    const message = JSON.stringify(request);
    const digestHex = ethers.id(message);
    const messageBytes = ethers.getBytes(digestHex);
    const { serialized: signature } = stateWallet.signingKey.sign(messageBytes);
    request.sig = [signature];
    
    return JSON.stringify(request);
  }, [stateWallet]);
  
  // Send a message to the ClearNode
  const sendMessage = useCallback((message) => {
    if (!ws || ws.readyState !== WebSocket.OPEN) {
      setError('WebSocket not connected');
      return false;
    }
    
    try {
      ws.send(typeof message === 'string' ? message : JSON.stringify(message));
      return true;
    } catch (error) {
      setError(`Error sending message: ${error.message}`);
      return false;
    }
  }, [ws]);
  
  // Connect to the ClearNode
  const connect = useCallback(() => {
    if (ws) {
      ws.close();
    }
    
    setConnectionStatus('connecting');
    setError(null);
    
    const newWs = new WebSocket(clearNodeUrl);
    
    newWs.onopen = async () => {
      setConnectionStatus('connected');
      
      // Start authentication process
      try {
        const authRequest = await createAuthRequestMessage(
          messageSigner,
          stateWallet.address
        );
        newWs.send(authRequest);
      } catch (err) {
        setError(`Authentication request failed: ${err.message}`);
      }
    };
    
    newWs.onmessage = async (event) => {
      try {
        const message = JSON.parse(event.data);
        
        // Handle authentication flow
        if (message.res && message.res[1] === 'auth_challenge') {
          try {
            const authVerify = await createAuthVerifyMessage(
              messageSigner,
              message,
              stateWallet.address
            );
            newWs.send(authVerify);
          } catch (err) {
            setError(`Authentication verification failed: ${err.message}`);
          }
        } else if (message.res && message.res[1] === 'auth_success') {
          setIsAuthenticated(true);
        } else if (message.res && message.res[1] === 'auth_failure') {
          setIsAuthenticated(false);
          setError(`Authentication failed: ${message.res[2]}`);
        }
        
        // Additional message handling can be added here
      } catch (err) {
        console.error('Error handling message:', err);
      }
    };
    
    newWs.onerror = (error) => {
      setError(`WebSocket error: ${error.message}`);
      setConnectionStatus('error');
    };
    
    newWs.onclose = () => {
      setConnectionStatus('disconnected');
      setIsAuthenticated(false);
    };
    
    setWs(newWs);
  }, [clearNodeUrl, messageSigner, stateWallet]);
  
  // Disconnect from the ClearNode
  const disconnect = useCallback(() => {
    if (ws) {
      ws.close();
      setWs(null);
    }
  }, [ws]);
  
  // Connect when the component mounts
  useEffect(() => {
    if (clearNodeUrl && stateWallet) {
      connect();
    }
    
    // Clean up on unmount
    return () => {
      if (ws) {
        ws.close();
      }
    };
  }, [clearNodeUrl, stateWallet, connect]);
  
  // Create helper methods for common operations
  const getChannels = useCallback(async () => {
    // Using the built-in helper function from NitroliteRPC
    const message = await createGetChannelsMessage(
      messageSigner,
      stateWallet.address
    );
    return sendMessage(message);
  }, [messageSigner, sendMessage, stateWallet]);
  
  const getLedgerBalances = useCallback(async (channelId) => {
    // Using the built-in helper function from NitroliteRPC
    const message = await createGetLedgerBalancesMessage(
      messageSigner,
      channelId
    );
    return sendMessage(message);
  }, [messageSigner, sendMessage]);
  
  const getConfig = useCallback(async () => {
    // Using the built-in helper function from NitroliteRPC
    const message = await createGetConfigMessage(
      messageSigner,
      stateWallet.address
    );
    return sendMessage(message);
  }, [messageSigner, sendMessage, stateWallet]);
  
  return {
    connectionStatus,
    isAuthenticated,
    error,
    ws,
    connect,
    disconnect,
    sendMessage,
    getChannels,
    getLedgerBalances,
    getConfig,
    createSignedRequest
  };
}

// Example usage in a component
function ClearNodeComponent() {
  const stateWallet = /* your state wallet initialization */;
  const {
    connectionStatus,
    isAuthenticated,
    error,
    getChannels
  } = useClearNodeConnection('wss://clearnode.example.com', stateWallet);
  
  return (
    <div>
      <p>Status: {connectionStatus}</p>
      <p>Authenticated: {isAuthenticated ? 'Yes' : 'No'}</p>
      {error && <p className="error">Error: {error}</p>}
      
      <button 
        onClick={getChannels} 
        disabled={!isAuthenticated}
      >
        Get Channels
      </button>
    </div>
  );
}
```

  </TabItem>
  <TabItem value="angular" label="Angular">

```typescript
// In an Angular service (clearnode.service.ts)
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';
import { ethers } from 'ethers';
import { 
  createAuthRequestMessage, 
  createAuthVerifyMessage,
  createGetChannelsMessage,
  createGetLedgerBalancesMessage,
  createGetConfigMessage,
  generateRequestId, 
  getCurrentTimestamp 
} from '@erc7824/nitrolite';

@Injectable({
  providedIn: 'root'
})
export class ClearNodeService {
  private ws: WebSocket | null = null;
  private connectionStatusSource = new BehaviorSubject<string>('disconnected');
  private isAuthenticatedSource = new BehaviorSubject<boolean>(false);
  private errorSource = new BehaviorSubject<string | null>(null);
  private messageSubject = new BehaviorSubject<any>(null);
  
  // Public observables
  connectionStatus$ = this.connectionStatusSource.asObservable();
  isAuthenticated$ = this.isAuthenticatedSource.asObservable();
  error$ = this.errorSource.asObservable();
  message$ = this.messageSubject.asObservable();
  
  // Custom message signer
  private async messageSigner(payload: any, stateWallet: any): Promise<string> {
    try {
      const message = JSON.stringify(payload);
      const digestHex = ethers.id(message);
      const messageBytes = ethers.getBytes(digestHex);
      const { serialized: signature } = stateWallet.signingKey.sign(messageBytes);
      return signature;
    } catch (error) {
      console.error("Error signing message:", error);
      throw error;
    }
  }
  
  // Create a signed request
  async createSignedRequest(method: string, params: any[], stateWallet: any): Promise<string> {
    const requestId = generateRequestId();
    const timestamp = getCurrentTimestamp();
    const requestData = [requestId, method, params, timestamp];
    const request: any = { req: requestData };
    
    // Sign the request
    const message = JSON.stringify(request);
    const digestHex = ethers.id(message);
    const messageBytes = ethers.getBytes(digestHex);
    const { serialized: signature } = stateWallet.signingKey.sign(messageBytes);
    request.sig = [signature];
    
    return JSON.stringify(request);
  }
  
  // Connect to the ClearNode
  connect(url: string, stateWallet: any): void {
    if (this.ws) {
      this.ws.close();
    }
    
    this.connectionStatusSource.next('connecting');
    this.errorSource.next(null);
    
    this.ws = new WebSocket(url);
    
    this.ws.onopen = async () => {
      this.connectionStatusSource.next('connected');
      
      // Start authentication process
      try {
        const authRequest = await createAuthRequestMessage(
          (payload) => this.messageSigner(payload, stateWallet),
          stateWallet.address
        );
        this.ws!.send(authRequest);
      } catch (err: any) {
        this.errorSource.next(`Authentication request failed: ${err.message}`);
      }
    };
    
    this.ws.onmessage = async (event) => {
      try {
        const message = JSON.parse(event.data);
        this.messageSubject.next(message);
        
        // Handle authentication flow
        if (message.res && message.res[1] === 'auth_challenge') {
          try {
            const authVerify = await createAuthVerifyMessage(
              (payload) => this.messageSigner(payload, stateWallet),
              message,
              stateWallet.address
            );
            this.ws!.send(authVerify);
          } catch (err: any) {
            this.errorSource.next(`Authentication verification failed: ${err.message}`);
          }
        } else if (message.res && message.res[1] === 'auth_success') {
          this.isAuthenticatedSource.next(true);
        } else if (message.res && message.res[1] === 'auth_failure') {
          this.isAuthenticatedSource.next(false);
          this.errorSource.next(`Authentication failed: ${message.res[2]}`);
        }
      } catch (err: any) {
        console.error('Error handling message:', err);
      }
    };
    
    this.ws.onerror = (error) => {
      this.errorSource.next(`WebSocket error`);
      this.connectionStatusSource.next('error');
    };
    
    this.ws.onclose = () => {
      this.connectionStatusSource.next('disconnected');
      this.isAuthenticatedSource.next(false);
    };
  }
  
  // Disconnect from the ClearNode
  disconnect(): void {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
  
  // Send a message to the ClearNode
  sendMessage(message: string | object): boolean {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      this.errorSource.next('WebSocket not connected');
      return false;
    }
    
    try {
      this.ws.send(typeof message === 'string' ? message : JSON.stringify(message));
      return true;
    } catch (error: any) {
      this.errorSource.next(`Error sending message: ${error.message}`);
      return false;
    }
  }
  
  // Helper methods for common operations
  async getChannels(stateWallet: any): Promise<boolean> {
    // Using the built-in helper function from NitroliteRPC
    const message = await createGetChannelsMessage(
      (payload) => this.messageSigner(payload, stateWallet),
      stateWallet.address
    );
    return this.sendMessage(message);
  }
  
  async getLedgerBalances(channelId: string, stateWallet: any): Promise<boolean> {
    // Using the built-in helper function from NitroliteRPC
    const message = await createGetLedgerBalancesMessage(
      (payload) => this.messageSigner(payload, stateWallet),
      channelId
    );
    return this.sendMessage(message);
  }
  
  async getConfig(stateWallet: any): Promise<boolean> {
    // Using the built-in helper function from NitroliteRPC
    const message = await createGetConfigMessage(
      (payload) => this.messageSigner(payload, stateWallet),
      stateWallet.address
    );
    return this.sendMessage(message);
  }
}

// Usage in a component
import { Component, OnInit, OnDestroy } from '@angular/core';
import { ClearNodeService } from './clearnode.service';
import { Subscription } from 'rxjs';

@Component({
  selector: 'app-clearnode',
  template: `
    <div>
      <p>Status: {{ connectionStatus }}</p>
      <p>Authenticated: {{ isAuthenticated ? 'Yes' : 'No' }}</p>
      <p *ngIf="error" class="error">Error: {{ error }}</p>
      
      <button 
        (click)="getChannels()" 
        [disabled]="!isAuthenticated"
      >
        Get Channels
      </button>
    </div>
  `
})
export class ClearNodeComponent implements OnInit, OnDestroy {
  connectionStatus = 'disconnected';
  isAuthenticated = false;
  error: string | null = null;
  
  private subscriptions: Subscription[] = [];
  private stateWallet: any; // Initialize your state wallet
  
  constructor(private clearNodeService: ClearNodeService) {}
  
  ngOnInit() {
    this.subscriptions.push(
      this.clearNodeService.connectionStatus$.subscribe(
        status => this.connectionStatus = status
      ),
      this.clearNodeService.isAuthenticated$.subscribe(
        auth => this.isAuthenticated = auth
      ),
      this.clearNodeService.error$.subscribe(
        err => this.error = err
      ),
      this.clearNodeService.message$.subscribe(
        message => {
          if (message) {
            console.log('Received message:', message);
            // Handle specific message types here
          }
        }
      )
    );
    
    // Connect to ClearNode
    this.clearNodeService.connect('wss://clearnode.example.com', this.stateWallet);
  }
  
  ngOnDestroy() {
    this.clearNodeService.disconnect();
    this.subscriptions.forEach(sub => sub.unsubscribe());
  }
  
  getChannels() {
    this.clearNodeService.getChannels(this.stateWallet);
  }
}
```

  </TabItem>
  <TabItem value="vue" label="Vue">

```javascript
// In a Vue component or Composable
import { ref, onMounted, onUnmounted } from 'vue';
import { ethers } from 'ethers';
import { 
  createAuthRequestMessage, 
  createAuthVerifyMessage,
  createGetChannelsMessage,
  createGetLedgerBalancesMessage,
  createGetConfigMessage,
  generateRequestId, 
  getCurrentTimestamp 
} from '@erc7824/nitrolite';

// ClearNode connection composable
export function useClearNodeConnection(clearNodeUrl, stateWallet) {
  const ws = ref(null);
  const connectionStatus = ref('disconnected');
  const isAuthenticated = ref(false);
  const error = ref(null);
  const messages = ref([]);
  
  // Message signer function
  const messageSigner = async (payload) => {
    try {
      const message = JSON.stringify(payload);
      const digestHex = ethers.id(message);
      const messageBytes = ethers.getBytes(digestHex);
      const { serialized: signature } = stateWallet.signingKey.sign(messageBytes);
      return signature;
    } catch (error) {
      console.error("Error signing message:", error);
      throw error;
    }
  };
  
  // Create a signed request
  const createSignedRequest = async (method, params = []) => {
    const requestId = generateRequestId();
    const timestamp = getCurrentTimestamp();
    const requestData = [requestId, method, params, timestamp];
    const request = { req: requestData };
    
    // Sign the request
    const message = JSON.stringify(request);
    const digestHex = ethers.id(message);
    const messageBytes = ethers.getBytes(digestHex);
    const { serialized: signature } = stateWallet.signingKey.sign(messageBytes);
    request.sig = [signature];
    
    return JSON.stringify(request);
  };
  
  // Send a message to the ClearNode
  const sendMessage = (message) => {
    if (!ws.value || ws.value.readyState !== WebSocket.OPEN) {
      error.value = 'WebSocket not connected';
      return false;
    }
    
    try {
      ws.value.send(typeof message === 'string' ? message : JSON.stringify(message));
      return true;
    } catch (err) {
      error.value = `Error sending message: ${err.message}`;
      return false;
    }
  };
  
  // Connect to the ClearNode
  const connect = () => {
    if (ws.value) {
      ws.value.close();
    }
    
    connectionStatus.value = 'connecting';
    error.value = null;
    
    const newWs = new WebSocket(clearNodeUrl);
    
    newWs.onopen = async () => {
      connectionStatus.value = 'connected';
      
      // Start authentication process
      try {
        const authRequest = await createAuthRequestMessage(
          messageSigner,
          stateWallet.address
        );
        newWs.send(authRequest);
      } catch (err) {
        error.value = `Authentication request failed: ${err.message}`;
      }
    };
    
    newWs.onmessage = async (event) => {
      try {
        const message = JSON.parse(event.data);
        messages.value.push(message);
        
        // Handle authentication flow
        if (message.res && message.res[1] === 'auth_challenge') {
          try {
            const authVerify = await createAuthVerifyMessage(
              messageSigner,
              message,
              stateWallet.address
            );
            newWs.send(authVerify);
          } catch (err) {
            error.value = `Authentication verification failed: ${err.message}`;
          }
        } else if (message.res && message.res[1] === 'auth_success') {
          isAuthenticated.value = true;
        } else if (message.res && message.res[1] === 'auth_failure') {
          isAuthenticated.value = false;
          error.value = `Authentication failed: ${message.res[2]}`;
        }
      } catch (err) {
        console.error('Error handling message:', err);
      }
    };
    
    newWs.onerror = (err) => {
      error.value = 'WebSocket error';
      connectionStatus.value = 'error';
    };
    
    newWs.onclose = () => {
      connectionStatus.value = 'disconnected';
      isAuthenticated.value = false;
    };
    
    ws.value = newWs;
  };
  
  // Disconnect from the ClearNode
  const disconnect = () => {
    if (ws.value) {
      ws.value.close();
      ws.value = null;
    }
  };
  
  // Helper methods for common operations
  const getChannels = async () => {
    // Using the built-in helper function from NitroliteRPC
    const message = await createGetChannelsMessage(
      messageSigner,
      stateWallet.address
    );
    return sendMessage(message);
  };
  
  const getLedgerBalances = async (channelId) => {
    // Using the built-in helper function from NitroliteRPC
    const message = await createGetLedgerBalancesMessage(
      messageSigner,
      channelId
    );
    return sendMessage(message);
  };
  
  const getConfig = async () => {
    // Using the built-in helper function from NitroliteRPC
    const message = await createGetConfigMessage(
      messageSigner,
      stateWallet.address
    );
    return sendMessage(message);
  };
  
  // Connect and disconnect with the component lifecycle
  onMounted(() => {
    if (clearNodeUrl && stateWallet) {
      connect();
    }
  });
  
  onUnmounted(() => {
    disconnect();
  });
  
  return {
    connectionStatus,
    isAuthenticated,
    error,
    messages,
    connect,
    disconnect,
    sendMessage,
    getChannels,
    getLedgerBalances,
    getConfig,
    createSignedRequest
  };
}

// Example usage in a Vue component
export default {
  setup() {
    // Initialize your state wallet
    const stateWallet = {}; 
    
    const {
      connectionStatus,
      isAuthenticated,
      error,
      messages,
      getChannels,
      getLedgerBalances,
      getConfig
    } = useClearNodeConnection('wss://clearnode.example.com', stateWallet);
    
    return {
      connectionStatus,
      isAuthenticated,
      error,
      messages,
      getChannels,
      getLedgerBalances,
      getConfig
    };
  }
};
```

  </TabItem>
  <TabItem value="nodejs" label="Node.js">

```javascript
const WebSocket = require('ws');
const { ethers } = require('ethers');
const { 
  createAuthRequestMessage, 
  createAuthVerifyMessage,
  createGetLedgerBalancesMessage,
  createGetConfigMessage,
  generateRequestId, 
  getCurrentTimestamp 
} = require('@erc7824/nitrolite');
const EventEmitter = require('events');

class ClearNodeConnection extends EventEmitter {
  constructor(url, stateWallet) {
    super();
    this.url = url;
    this.stateWallet = stateWallet;
    this.ws = null;
    this.isConnected = false;
    this.isAuthenticated = false;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.reconnectInterval = 3000; // ms
    this.requestMap = new Map(); // Track pending requests
  }
  
  // Message signer function
  async messageSigner(payload) {
    try {
      const message = JSON.stringify(payload);
      const digestHex = ethers.id(message);
      const messageBytes = ethers.getBytes(digestHex);
      const { serialized: signature } = this.stateWallet.signingKey.sign(messageBytes);
      return signature;
    } catch (error) {
      console.error("Error signing message:", error);
      throw error;
    }
  }
  
  // Create a signed request
  async createSignedRequest(method, params = [], requestId = generateRequestId()) {
    const timestamp = getCurrentTimestamp();
    const requestData = [requestId, method, params, timestamp];
    const request = { req: requestData };
    
    // Sign the request
    const message = JSON.stringify(request);
    const digestHex = ethers.id(message);
    const messageBytes = ethers.getBytes(digestHex);
    const { serialized: signature } = this.stateWallet.signingKey.sign(messageBytes);
    request.sig = [signature];
    
    return { request, requestId };
  }
  
  // Connect to the ClearNode
  async connect() {
    return new Promise((resolve, reject) => {
      if (this.ws) {
        this.ws.close();
      }
      
      this.emit('connecting');
      
      this.ws = new WebSocket(this.url);
      
      // Set connection timeout
      const connectionTimeout = setTimeout(() => {
        if (!this.isConnected) {
          this.ws.close();
          reject(new Error('Connection timeout'));
        }
      }, 10000);
      
      this.ws.on('open', async () => {
        clearTimeout(connectionTimeout);
        this.isConnected = true;
        this.reconnectAttempts = 0;
        this.emit('connected');
        
        // Start authentication
        try {
          const authRequest = await createAuthRequestMessage(
            (payload) => this.messageSigner(payload),
            this.stateWallet.address
          );
          
          this.ws.send(authRequest);
          // Do not resolve here, wait for auth_success
        } catch (error) {
          this.emit('error', `Authentication request failed: ${error.message}`);
          reject(error);
        }
      });
      
      this.ws.on('message', async (data) => {
        try {
          const message = JSON.parse(data);
          this.emit('message', message);
          
          // Handle authentication flow
          if (message.res && message.res[1] === 'auth_challenge') {
            try {
              const authVerify = await createAuthVerifyMessage(
                (payload) => this.messageSigner(payload),
                message,
                this.stateWallet.address
              );
              
              this.ws.send(authVerify);
            } catch (error) {
              this.emit('error', `Authentication verification failed: ${error.message}`);
              reject(error);
            }
          } else if (message.res && message.res[1] === 'auth_success') {
            this.isAuthenticated = true;
            this.emit('authenticated');
            resolve(); // Authentication successful
          } else if (message.res && message.res[1] === 'auth_failure') {
            this.isAuthenticated = false;
            const error = new Error(`Authentication failed: ${message.res[2]}`);
            this.emit('error', error.message);
            reject(error);
          }
          
          // Handle other response types
          if (message.res && message.res[0]) {
            const requestId = message.res[0];
            const handler = this.requestMap.get(requestId);
            if (handler) {
              handler.resolve(message);
              this.requestMap.delete(requestId);
            }
          }
        } catch (error) {
          console.error('Error handling message:', error);
        }
      });
      
      this.ws.on('error', (error) => {
        clearTimeout(connectionTimeout);
        this.emit('error', `WebSocket error: ${error.message}`);
        reject(error);
      });
      
      this.ws.on('close', (code, reason) => {
        clearTimeout(connectionTimeout);
        this.isConnected = false;
        this.isAuthenticated = false;
        this.emit('disconnected', { code, reason: reason.toString() });
        
        // Attempt to reconnect
        this.attemptReconnect();
      });
    });
  }
  
  // Send a request and wait for the response
  async sendRequest(method, params = []) {
    if (!this.isConnected || !this.isAuthenticated) {
      throw new Error('Not connected or authenticated');
    }
    
    const { request, requestId } = await this.createSignedRequest(method, params);
    
    return new Promise((resolve, reject) => {
      // Set up response handler
      const timeout = setTimeout(() => {
        this.requestMap.delete(requestId);
        reject(new Error(`Request timeout for ${method}`));
      }, 30000);
      
      this.requestMap.set(requestId, {
        resolve: (response) => {
          clearTimeout(timeout);
          resolve(response);
        },
        reject,
        timeout
      });
      
      // Send the request
      try {
        this.ws.send(JSON.stringify(request));
      } catch (error) {
        clearTimeout(timeout);
        this.requestMap.delete(requestId);
        reject(error);
      }
    });
  }
  
  // Helper methods for common operations
  async getChannels() {
    // Using the built-in helper function from NitroliteRPC
    const message = await createGetChannelsMessage(
      (payload) => this.messageSigner(payload),
      this.stateWallet.address
    );
    
    return new Promise((resolve, reject) => {
      try {
        const parsed = JSON.parse(message);
        const requestId = parsed.req[0];
        
        const timeout = setTimeout(() => {
          this.requestMap.delete(requestId);
          reject(new Error('Request timeout for getChannels'));
        }, 30000);
        
        this.requestMap.set(requestId, {
          resolve: (response) => {
            clearTimeout(timeout);
            resolve(response);
          },
          reject,
          timeout
        });
        
        this.ws.send(message);
      } catch (error) {
        reject(error);
      }
    });
  }
  
  async getLedgerBalances(channelId) {
    // Using the built-in helper function from NitroliteRPC
    const message = await createGetLedgerBalancesMessage(
      (payload) => this.messageSigner(payload),
      channelId
    );
    
    return new Promise((resolve, reject) => {
      try {
        const parsed = JSON.parse(message);
        const requestId = parsed.req[0];
        
        const timeout = setTimeout(() => {
          this.requestMap.delete(requestId);
          reject(new Error('Request timeout for getLedgerBalances'));
        }, 30000);
        
        this.requestMap.set(requestId, {
          resolve: (response) => {
            clearTimeout(timeout);
            resolve(response);
          },
          reject,
          timeout
        });
        
        this.ws.send(message);
      } catch (error) {
        reject(error);
      }
    });
  }
  
  async getConfig() {
    // Using the built-in helper function from NitroliteRPC
    const message = await createGetConfigMessage(
      (payload) => this.messageSigner(payload),
      this.stateWallet.address
    );
    
    return new Promise((resolve, reject) => {
      try {
        const parsed = JSON.parse(message);
        const requestId = parsed.req[0];
        
        const timeout = setTimeout(() => {
          this.requestMap.delete(requestId);
          reject(new Error('Request timeout for getConfig'));
        }, 30000);
        
        this.requestMap.set(requestId, {
          resolve: (response) => {
            clearTimeout(timeout);
            resolve(response);
          },
          reject,
          timeout
        });
        
        this.ws.send(message);
      } catch (error) {
        reject(error);
      }
    });
  }
  
  // Attempt to reconnect with exponential backoff
  attemptReconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      this.emit('error', 'Maximum reconnection attempts reached');
      return;
    }
    
    this.reconnectAttempts++;
    const delay = this.reconnectInterval * Math.pow(2, this.reconnectAttempts - 1);
    
    this.emit('reconnecting', { attempt: this.reconnectAttempts, delay });
    
    setTimeout(() => {
      this.connect().catch(error => {
        console.error(`Reconnection attempt ${this.reconnectAttempts} failed:`, error);
      });
    }, delay);
  }
  
  // Disconnect from the ClearNode
  disconnect() {
    if (this.ws) {
      // Clear all pending requests
      for (const [requestId, handler] of this.requestMap.entries()) {
        clearTimeout(handler.timeout);
        handler.reject(new Error('Connection closed'));
        this.requestMap.delete(requestId);
      }
      
      this.ws.close(1000, 'User initiated disconnect');
      this.ws = null;
    }
  }
}

// Example usage
async function main() {
  // Initialize your state wallet (this is just a placeholder)
  const privateKey = '0x1234...'; // Your private key
  const stateWallet = new ethers.Wallet(privateKey);
  
  // Create a ClearNode connection
  const clearNode = new ClearNodeConnection('wss://clearnode.example.com', stateWallet);
  
  // Set up event handlers
  clearNode.on('connecting', () => {
    console.log('Connecting to ClearNode...');
  });
  
  clearNode.on('connected', () => {
    console.log('Connected to ClearNode');
  });
  
  clearNode.on('authenticated', () => {
    console.log('Authenticated with ClearNode');
  });
  
  clearNode.on('disconnected', ({ code, reason }) => {
    console.log(`Disconnected from ClearNode: ${code} ${reason}`);
  });
  
  clearNode.on('error', (error) => {
    console.error(`ClearNode error: ${error}`);
  });
  
  clearNode.on('reconnecting', ({ attempt, delay }) => {
    console.log(`Reconnecting (${attempt}/${clearNode.maxReconnectAttempts}) in ${delay}ms...`);
  });
  
  try {
    // Connect and authenticate
    await clearNode.connect();
    console.log('Successfully connected and authenticated');
    
    // Get channels
    const channels = await clearNode.getChannels();
    console.log('Channels:', channels.res[2][0]);
    
    // Process the channels
    const channelList = channels.res[2][0];
    if (channelList && channelList.length > 0) {
      for (const channel of channelList) {
        console.log(`Channel ID: ${channel.channel_id}`);
        console.log(`Status: ${channel.status}`);
        console.log(`Token: ${channel.token}`);
        
        // Get ledger balances for the channel
        if (channel.status === 'open') {
          const balances = await clearNode.getLedgerBalances(channel.channel_id);
          console.log(`Balances:`, balances.res[2]);
        }
      }
    } else {
      console.log('No channels found');
    }
  } catch (error) {
    console.error('Error:', error);
  } finally {
    // Disconnect when done
    clearNode.disconnect();
  }
}

// Handle process termination
process.on('SIGINT', () => {
  console.log('Shutting down...');
  // Clean up resources here
  process.exit(0);
});

// Run the example
main().catch(console.error);
```

  </TabItem>
</Tabs>


## Security Considerations

When working with ClearNodes and state channels, keep these security best practices in mind:

1. **Secure State Wallet Storage**: Properly encrypt and secure the private key for your state wallet
2. **Verify Message Signatures**: Always verify that received messages have valid signatures from expected sources
3. **Monitor Connection Status**: Implement monitoring to detect unexpected disconnections or authentication failures
4. **Implement Timeout Handling**: Add timeouts for operations to prevent hanging on unresponsive connections
5. **Validate Channel States**: Verify that channel states are valid before processing or saving them
6. **Use Secure WebSocket Connections**: Always use `wss://` (WebSocket Secure) for ClearNode connections, never `ws://`
7. **Implement Rate Limiting**: Add protection against excessive message sending to prevent abuse

## Troubleshooting Common Issues

| Issue | Possible Causes | Solution |
|-------|----------------|----------|
| Connection timeout | Network latency, ClearNode unavailable | Implement retry logic with exponential backoff |
| Authentication failure | Invalid state wallet, incorrect signing | Verify your state wallet is properly initialized and signing correctly |
| Frequent disconnections | Unstable network, server-side issues | Monitor connection events and implement automatic reconnection |
| Message delivery failures | Connection issues, invalid message format | Add message queuing and confirmation mechanism |
| Invalid signature errors | EIP-191 prefix issues | Ensure you're signing raw message bytes without the EIP-191 prefix |

## Next Steps

After successfully connecting to a ClearNode, you can:

1. [View and manage channel assets](balances)
2. [Create an application session](application_session)
3. [Start transacting off-chain](application_session#sending-transactions)
4. [Explore advanced channel operations](resize_channel)

---

---
sidebar_position: 6
title: Channel Asset Management
description: Monitor off-chain balances in your active state channels using NitroliteRPC.
keywords: [erc7824, nitrolite, balances, off-chain, ledger balances, clearnode]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Channel Asset Management

After connecting to a ClearNode, you'll need to monitor the off-chain balances in your state channels. This guide explains how to retrieve and work with off-chain balance information using the NitroliteRPC protocol.

## Understanding Off-Chain Balances

Off-chain balances in Nitrolite represent:

- Your current funds in the state channel
- Balances that update in real-time as transactions occur
- The source of truth for application operations
- Assets that are backed by on-chain deposits

## Checking Off-Chain Balances

To monitor your channel funds, you need to retrieve the current off-chain balances from the ClearNode.

## Understanding the Ledger Balances Request

The `get_ledger_balances` request is used to retrieve the current off-chain balances for a specific participant from the ClearNode:

- **Request params**: `[{ participant: "0xAddress" }]` where `0xAddress` is the participant's address
- **Response**: Array containing the balances for different assets held by the participant

The response contains a list of assets and their amounts for the specified participant. The balances are represented as strings with decimal precision, making it easier to display them directly without additional conversion.

```javascript
// Example response format for get_ledger_balances
{
  "res": [1, "get_ledger_balances", [[  // The nested array contains balance data
    {
      "asset": "usdc",  // Asset identifier
      "amount": "100.0"  // Amount as a string with decimal precision
    },
    {
      "asset": "eth",
      "amount": "0.5"
    }
  ]], 1619123456789],  // Timestamp
  "sig": ["0xabcd1234..."]
}
```

To retrieve these balances, use the `get_ledger_balances` request with the ClearNode:

<Tabs>
  <TabItem value="using-helper" label="Using SDK Helper">

```javascript
import { createGetLedgerBalancesMessage } from '@erc7824/nitrolite';
import { ethers } from 'ethers';

// Your message signer function (same as in auth flow)
const messageSigner = async (payload) => {
  const message = JSON.stringify(payload);
  const digestHex = ethers.id(message);
  const messageBytes = ethers.getBytes(digestHex);
  const { serialized: signature } = stateWallet.signingKey.sign(messageBytes);
  return signature;
};

// Function to get ledger balances
async function getLedgerBalances(ws, participant) {
  return new Promise((resolve, reject) => {
    // Create a unique handler for this specific request
    const handleMessage = (event) => {
      const message = JSON.parse(event.data);
      
      // Check if this is a response to our get_ledger_balances request
      if (message.res && message.res[1] === 'get_ledger_balances') {
        // Remove the message handler to avoid memory leaks
        ws.removeEventListener('message', handleMessage);
        
        // Resolve with the balances data
        resolve(message.res[2]);
      }
    };
    
    // Add the message handler
    ws.addEventListener('message', handleMessage);
    
    // Create and send the ledger balances request
    createGetLedgerBalancesMessage(messageSigner, participant)
      .then(message => {
        ws.send(message);
      })
      .catch(error => {
        // Remove the message handler on error
        ws.removeEventListener('message', handleMessage);
        reject(error);
      });
      
    // Set a timeout to prevent hanging indefinitely
    setTimeout(() => {
      ws.removeEventListener('message', handleMessage);
      reject(new Error('Timeout waiting for ledger balances'));
    }, 10000); // 10 second timeout
  });
}

// Usage example
const participantAddress = '0x1234567890abcdef1234567890abcdef12345678';

try {
  const balances = await getLedgerBalances(ws, participantAddress);
  
  console.log('Channel ledger balances:', balances);
  // Example output:
  // [
  //   [
  //     { "asset": "usdc", "amount": "100.0" },
  //     { "asset": "eth", "amount": "0.5" }
  //   ]
  // ]
  
  // Process your balances
  if (balances[0] && balances[0].length > 0) {
    const balanceList = balances[0]; // Array of balance entries by asset
    
    // Display each asset balance
    balanceList.forEach(balance => {
      console.log(`${balance.asset.toUpperCase()} balance: ${balance.amount}`);
    });
    
    // Example: find a specific asset
    const usdcBalance = balanceList.find(b => b.asset.toLowerCase() === 'usdc');
    if (usdcBalance) {
      console.log(`USDC balance: ${usdcBalance.amount}`);
    }
  } else {
    console.log('No balance data available');
  }
} catch (error) {
  console.error('Failed to get ledger balances:', error);
}
```

  </TabItem>
  <TabItem value="manual" label="Manual Request">

```javascript
import { ethers } from 'ethers';
import { generateRequestId, getCurrentTimestamp } from '@erc7824/nitrolite';

// Function to create a signed ledger balances request
async function createLedgerBalancesRequest(signer, participant) {
  const requestId = generateRequestId();
  const method = 'get_ledger_balances';
  const params = [{ participant }]; // Note: updated parameter name to 'participant'
  const timestamp = getCurrentTimestamp();
  
  // Create the request structure
  const requestData = [requestId, method, params, timestamp];
  const request = { req: requestData };
  
  // Sign the request
  const message = JSON.stringify(request);
  const digestHex = ethers.id(message);
  const messageBytes = ethers.getBytes(digestHex);
  const { serialized: signature } = signer.wallet.signingKey.sign(messageBytes);
  
  // Add signature to the request
  request.sig = [signature];
  
  return { stringified: JSON.stringify(request), requestId };
}

// Function to get ledger balances
async function getLedgerBalances(ws, participant, signer) {
  return new Promise((resolve, reject) => {
    createLedgerBalancesRequest(signer, participant)
      .then(({ stringified, requestId }) => {
        // Set up message handler
        const handleMessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            
            // Check if this is our response
            if (message.res && 
                message.res[0] === requestId && 
                message.res[1] === 'get_ledger_balances') {
              
              // Remove the listener
              ws.removeEventListener('message', handleMessage);
              
              // Resolve with the balances data
              resolve(message.res[2]);
            }
          } catch (error) {
            console.error('Error parsing message:', error);
          }
        };
        
        // Add message listener
        ws.addEventListener('message', handleMessage);
        
        // Send the request
        ws.send(stringified);
        
        // Set timeout
        setTimeout(() => {
          ws.removeEventListener('message', handleMessage);
          reject(new Error('Timeout waiting for ledger balances'));
        }, 10000);
      })
      .catch(reject);
  });
}

// Usage example
const participantAddress = '0x1234567890abcdef1234567890abcdef12345678';

try {
  const balances = await getLedgerBalances(ws, participantAddress, stateWallet);
  
  console.log('Channel ledger balances:', balances);
  // Process and display balances
  // ...
  
} catch (error) {
  console.error('Failed to get ledger balances:', error);
}
```

  </TabItem>
</Tabs>

## Checking Balances for a Participant

To retrieve off-chain balances for a participant, use the `createGetLedgerBalancesMessage` helper function:

```javascript
import { createGetLedgerBalancesMessage } from '@erc7824/nitrolite';
import { ethers } from 'ethers';

// Function to get ledger balances for a participant
async function getLedgerBalances(ws, participant, messageSigner) {
  return new Promise((resolve, reject) => {
    // Message handler for the response
    const handleMessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        
        // Check if this is a response to our get_ledger_balances request
        if (message.res && message.res[1] === 'get_ledger_balances') {
          // Clean up by removing the event listener
          ws.removeEventListener('message', handleMessage);
          
          // Resolve with the balance data
          resolve(message.res[2]);
        }
      } catch (error) {
        console.error('Error parsing message:', error);
      }
    };
    
    // Set up timeout to avoid hanging indefinitely
    const timeoutId = setTimeout(() => {
      ws.removeEventListener('message', handleMessage);
      reject(new Error('Timeout waiting for ledger balances'));
    }, 10000); // 10 second timeout
    
    // Add the message handler
    ws.addEventListener('message', handleMessage);
    
    // Create and send the balance request
    createGetLedgerBalancesMessage(messageSigner, participant)
      .then(message => {
        ws.send(message);
      })
      .catch(error => {
        clearTimeout(timeoutId);
        ws.removeEventListener('message', handleMessage);
        reject(error);
      });
  });
}

// Example usage
const participantAddress = '0x1234567890abcdef1234567890abcdef12345678';

getLedgerBalances(ws, participantAddress, messageSigner)
  .then(balances => {
    console.log('Channel balances:', balances);
    
    // Process and display your balances
    if (balances[0] && balances[0].length > 0) {
      const balanceList = balances[0]; // Array of balance entries by asset
      
      console.log('My balances:');
      balanceList.forEach(balance => {
        console.log(`- ${balance.asset.toUpperCase()}: ${balance.amount}`);
      });
    } else {
      console.log('No balance data available');
    }
  })
  .catch(error => {
    console.error('Failed to get ledger balances:', error);
  });
```

## Processing Balance Data

When you receive balance data from the ClearNode, it's helpful to format it for better readability:

```javascript
// Simple function to format your balance data for display
function formatMyBalances(balances) {
  if (!balances || !balances[0] || !Array.isArray(balances[0]) || balances[0].length === 0) {
    return null; // No balance data available
  }
  
  // Extract your balances from the nested structure
  const balanceList = balances[0]; // Array of balance entries by asset
  
  // Return formatted balance information
  return balanceList.map(balance => ({
    asset: balance.asset.toUpperCase(),
    amount: balance.amount,
    // You can add additional formatting here if needed
    displayAmount: `${balance.amount} ${balance.asset.toUpperCase()}`
  }));
}

// Example usage
const myFormattedBalances = formatMyBalances(balancesFromClearNode);

if (myFormattedBalances && myFormattedBalances.length > 0) {
  console.log('My balances:');
  myFormattedBalances.forEach(balance => {
    console.log(`- ${balance.displayAmount}`);
  });
} else {
  console.log('No balance data available');
}
```

## Best Practices for Balance Checking

When working with off-chain balances, follow these best practices:

### Regular Balance Polling

Set up a regular interval to check balances, especially in active applications:

```javascript
// Simple balance monitoring function
function startBalanceMonitoring(ws, participantAddress, messageSigner, intervalMs = 30000) {
  // Check immediately on start
  getLedgerBalances(ws, participantAddress, messageSigner)
    .then(displayBalances)
    .catch(err => console.error('Initial balance check failed:', err));
  
  // Set up interval for regular checks
  const intervalId = setInterval(() => {
    getLedgerBalances(ws, participantAddress, messageSigner)
      .then(displayBalances)
      .catch(err => console.error('Balance check failed:', err));
  }, intervalMs); // Check every 30 seconds by default
  
  // Return function to stop monitoring
  return () => clearInterval(intervalId);
}

// Simple display function
function displayBalances(balances) {
  console.log(`Balance update at ${new Date().toLocaleTimeString()}:`);
  
  // Format and display your balances
  if (balances[0] && balances[0].length > 0) {
    const balanceList = balances[0]; // Array of balance entries by asset
    
    console.log('My balances:');
    balanceList.forEach(balance => {
      console.log(`- ${balance.asset.toUpperCase()}: ${balance.amount}`);
    });
  } else {
    console.log('No balance data available');
  }
}
```

## Common Errors and Troubleshooting

When retrieving off-chain balances, you might encounter these common issues:

| Error Type | Description | Solution |
|------------|-------------|----------|
| **Authentication errors** | WebSocket connection loses authentication | Re-authenticate before requesting balances again |
| **Channel not found** | The channel ID is invalid or the channel has been closed | Verify the channel ID and check if the channel is still active |
| **Connection issues** | WebSocket disconnects during a balance request | Implement reconnection logic with exponential backoff |
| **Timeout** | The ClearNode does not respond in a timely manner | Set appropriate timeouts and implement retry logic |

## Next Steps

Now that you understand how to monitor off-chain balances in your channels, you can:

1. [Create an application session](application_session) to start transacting off-chain 
2. [Resize your channel](resize_channel) if you need to adjust fund allocation
3. Learn about [channel closing](close_session) when you're done with the channel

---

---
sidebar_position: 7
title: Create Application Sessions
description: Create and manage off-chain application sessions to interact with ClearNodes.
keywords: [erc7824, nitrolite, application session, state channels, app session]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Create Application Sessions

After connecting to a ClearNode and checking your channel balances, you can create application sessions to interact with specific applications on the state channel network. Application sessions allow you to perform off-chain transactions and define custom behavior for your interactions.

## Understanding Application Sessions

Application sessions in Nitrolite allow you to:

- Create isolated environments for specific interactions
- Define rules for off-chain transactions
- Specify how funds are allocated between participants
- Implement custom application logic and state management

An application session serves as a mechanism to track and manage interactions between participants, with the ClearNode acting as a facilitator.

## Creating an Application Session

To create an application session, you'll use the `createAppSessionMessage` helper from NitroliteRPC. Here's how to do it:

<Tabs>
  <TabItem value="react" label="React">

```javascript
import { createAppSessionMessage } from '@erc7824/nitrolite';
import { useCallback } from 'react';

function useCreateApplicationSession() {
  const createApplicationSession = useCallback(
    async (
      signer,
      sendRequest,
      participantA,
      participantB,
      amount,
    ) => {
      try {
        // Define the application parameters
        const appDefinition = {
          protocol: 'nitroliterpc',
          participants: [participantA, participantB],
          weights: [100, 0],  // Weight distribution for consensus
          quorum: 100,        // Required consensus percentage
          challenge: 0,       // Challenge period
          nonce: Date.now(),  // Unique identifier
        };

        // Define allocations with asset type instead of token address
        const allocations = [
          {
            participant: participantA,
            asset: 'usdc',
            amount: amount,
          },
          {
            participant: participantB,
            asset: 'usdc',
            amount: '0',
          },
        ];

        // Create a signed message using the createAppSessionMessage helper
        const signedMessage = await createAppSessionMessage(
          signer.sign,
          [
            {
              definition: appDefinition,
              allocations: allocations,
            },
          ]
        );

        // Send the signed message to the ClearNode
        const response = await sendRequest(signedMessage);

        // Handle the response
        if (response && response[0] && response[0].app_session_id) {
          // Store the app session ID for future reference
          localStorage.setItem('app_session_id', response[0].app_session_id);
          return { success: true, app_session_id: response[0].app_session_id, response };
        } else {
          return { success: true, response };
        }
      } catch (error) {
        console.error('Error creating application session:', error);
        return {
          success: false,
          error: error instanceof Error
            ? error.message
            : 'Unknown error during session creation',
        };
      }
    },
    []
  );

  return { createApplicationSession };
}

// Usage example
function MyComponent() {
  const { createApplicationSession } = useCreateApplicationSession();
  
  const handleCreateSession = async () => {
    // Define your WebSocket send wrapper
    const sendRequest = async (payload) => {
      return new Promise((resolve, reject) => {
        // Assuming ws is your WebSocket connection
        const handleMessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            if (message.res && message.res[1] === 'create_app_session') {
              ws.removeEventListener('message', handleMessage);
              resolve(message.res[2]);
            }
          } catch (error) {
            console.error('Error parsing message:', error);
          }
        };
        
        ws.addEventListener('message', handleMessage);
        ws.send(payload);
        
        // Set timeout to prevent hanging
        setTimeout(() => {
          ws.removeEventListener('message', handleMessage);
          reject(new Error('App session creation timeout'));
        }, 10000);
      });
    };
    
    const result = await createApplicationSession(
      walletSigner,      // Your signer object
      sendRequest,       // Function to send the request
      '0xYourAddress',   // Your address
      '0xOtherAddress',  // Other participant's address
      '100',             // Amount
    );
    
    if (result.success) {
      console.log(`Application session created with ID: ${result.app_session_id}`);
    } else {
      console.error(`Failed to create application session: ${result.error}`);
    }
  };
  
  return (
    <button onClick={handleCreateSession}>Create Application Session</button>
  );
}
```

  </TabItem>
  <TabItem value="angular" label="Angular">

```typescript
// app-session.service.ts
import { Injectable } from '@angular/core';
import { createAppSessionMessage } from '@erc7824/nitrolite';
import { ethers } from 'ethers';
import { BehaviorSubject, Observable, from } from 'rxjs';
import { tap, catchError } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class AppSessionService {
  private webSocket: WebSocket | null = null;
  private appIdSubject = new BehaviorSubject<string | null>(null);
  
  public appId$ = this.appIdSubject.asObservable();
  
  constructor() {
    // Retrieve app ID from storage if available
    const storedAppId = localStorage.getItem('app_session_id');
    if (storedAppId) {
      this.appIdSubject.next(storedAppId);
    }
  }
  
  public setWebSocket(ws: WebSocket): void {
    this.webSocket = ws;
  }
  
  public createApplicationSession(
    signer: any,
    participantA: string,
    participantB: string,
    amount: string,
  ): Observable<any> {
    if (!this.webSocket) {
      throw new Error('WebSocket connection is not established');
    }
    
    return from(this.createAppSessionAsync(
      signer,
      participantA,
      participantB,
      amount,
    )).pipe(
      tap(result => {
        if (result.success && result.app_session_id) {
          localStorage.setItem('app_session_id', result.app_session_id);
          this.appIdSubject.next(result.app_session_id);
        }
      }),
      catchError(error => {
        console.error('Error creating application session:', error);
        throw error;
      })
    );
  }
  
  private async createAppSessionAsync(
    signer: any,
    participantA: string,
    participantB: string,
    amount: string,
  ): Promise<any> {
    try {
      
      // Define the application parameters
      const appDefinition = {
        protocol: 'nitroliterpc',
        participants: [participantA, participantB],
        weights: [100, 0],
        quorum: 100,
        challenge: 0,
        nonce: Date.now(),
      };
      
      // Define the allocations with asset type
      const allocations = [
        {
          participant: participantA,
          asset: 'usdc',
          amount: amount,
        },
        {
          participant: participantB,
          asset: 'usdc',
          amount: '0',
        },
      ];
      
      // Create message signer function
      const messageSigner = async (payload: any) => {
        const message = JSON.stringify(payload);
        const digestHex = ethers.id(message);
        const messageBytes = ethers.getBytes(digestHex);
        const signature = await signer.signMessage(messageBytes);
        return signature;
      };
      
      // Create the signed message
      const signedMessage = await createAppSessionMessage(
        messageSigner,
        [
          {
            definition: appDefinition,
            allocations: allocations,
          },
        ]
      );
      
      // Send the message and wait for response
      return await this.sendRequest(signedMessage);
    } catch (error) {
      console.error('Error in createAppSessionAsync:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }
  
  private sendRequest(payload: string): Promise<any> {
    return new Promise((resolve, reject) => {
      if (!this.webSocket) {
        reject(new Error('WebSocket not connected'));
        return;
      }
      
      const handleMessage = (event: MessageEvent) => {
        try {
          const message = JSON.parse(event.data);
          if (message.res && message.res[1] === 'create_app_session') {
            this.webSocket?.removeEventListener('message', handleMessage);
            resolve({
              success: true,
              app_session_id: message.res[2]?.[0]?.app_session_id || null,
              status: message.res[2]?.[0]?.status || "open",
              response: message.res[2]
            });
          }
          
          if (message.err) {
            this.webSocket?.removeEventListener('message', handleMessage);
            reject(new Error(`Error: ${message.err[1]} - ${message.err[2]}`));
          }
        } catch (error) {
          console.error('Error parsing message:', error);
        }
      };
      
      this.webSocket.addEventListener('message', handleMessage);
      this.webSocket.send(payload);
      
      // Set timeout to prevent hanging
      setTimeout(() => {
        this.webSocket?.removeEventListener('message', handleMessage);
        reject(new Error('App session creation timeout'));
      }, 10000);
    });
  }
}

// app-session.component.ts
import { Component, OnInit } from '@angular/core';
import { AppSessionService } from './app-session.service';

@Component({
  selector: 'app-session-creator',
  template: `
    <div class="app-session-container">
      <h3>Create Application Session</h3>
      <div *ngIf="appId">
        Current Application Session ID: {{ appId }}
      </div>
      <button (click)="createAppSession()" [disabled]="isCreating">
        {{ isCreating ? 'Creating...' : 'Create Application Session' }}
      </button>
      <div *ngIf="error" class="error-message">
        {{ error }}
      </div>
    </div>
  `,
  styles: [`
    .app-session-container {
      margin: 20px;
      padding: 15px;
      border: 1px solid #eee;
      border-radius: 5px;
    }
    .error-message {
      color: red;
      margin-top: 10px;
    }
  `]
})
export class AppSessionComponent implements OnInit {
  appId: string | null = null;
  isCreating = false;
  error: string | null = null;
  
  constructor(private appSessionService: AppSessionService) {}
  
  ngOnInit(): void {
    // Subscribe to app ID changes
    this.appSessionService.appId$.subscribe(id => {
      this.appId = id;
    });
    
    // Initialize WebSocket (implementation would depend on your setup)
    const ws = new WebSocket('wss://your-clearnode-endpoint');
    ws.onopen = () => {
      this.appSessionService.setWebSocket(ws);
    };
  }
  
  createAppSession(): void {
    this.isCreating = true;
    this.error = null;
    
    // Sample values - in a real app you'd get these from input fields or a service
    const participantA = '0xYourAddress';
    const participantB = '0xOtherAddress';
    const amount = '1000000'; // 1 USDC with 6 decimals
    
    // Assuming you have access to a signer (e.g., from MetaMask)
    const signer = window.ethereum && new ethers.providers.Web3Provider(window.ethereum).getSigner();
    
    if (!signer) {
      this.error = 'No wallet connected';
      this.isCreating = false;
      return;
    }
    
    this.appSessionService.createApplicationSession(
      signer,
      participantA,
      participantB,
      amount
    ).subscribe({
      next: (result) => {
        console.log('App session created:', result);
        this.isCreating = false;
      },
      error: (err) => {
        this.error = `Failed to create application session: ${err.message}`;
        this.isCreating = false;
      }
    });
  }
}
```

  </TabItem>
  <TabItem value="vue" label="Vue.js">

```javascript
<!-- AppSessionManager.vue -->
<template>
  <div class="app-session-manager">
    <h3>Application Session</h3>
    
    <div v-if="appId" class="current-session">
      <p>Current session ID: {{ appId }}</p>
    </div>
    
    <div class="create-session">
      <button 
        @click="createAppSession" 
        :disabled="isCreating || !isConnected"
      >
        {{ isCreating ? 'Creating...' : 'Create Application Session' }}
      </button>
      
      <div v-if="error" class="error-message">
        {{ error }}
      </div>
      
      <div v-if="!isConnected" class="warning-message">
        WebSocket not connected to ClearNode
      </div>
    </div>
  </div>
</template>

<script>
import { defineComponent, ref, onMounted, onUnmounted } from 'vue';
import { createAppSessionMessage } from '@erc7824/nitrolite';
import { ethers } from 'ethers';

export default defineComponent({
  name: 'AppSessionManager',
  
  setup() {
    const appId = ref(localStorage.getItem('app_session_id') || null);
    const isCreating = ref(false);
    const error = ref(null);
    const isConnected = ref(false);
    let webSocket = null;
    
    onMounted(() => {
      // Initialize WebSocket connection
      initWebSocket();
    });
    
    onUnmounted(() => {
      // Clean up WebSocket connection
      if (webSocket) {
        webSocket.close();
      }
    });
    
    const initWebSocket = () => {
      webSocket = new WebSocket('wss://your-clearnode-endpoint');
      
      webSocket.onopen = () => {
        isConnected.value = true;
        console.log('WebSocket connected to ClearNode');
      };
      
      webSocket.onclose = () => {
        isConnected.value = false;
        console.log('WebSocket disconnected from ClearNode');
      };
      
      webSocket.onerror = (e) => {
        isConnected.value = false;
        error.value = 'WebSocket connection error';
        console.error('WebSocket error:', e);
      };
    };
    
    const createAppSession = async () => {
      if (!isConnected.value || !webSocket) {
        error.value = 'WebSocket not connected';
        return;
      }
      
      try {
        isCreating.value = true;
        error.value = null;
        
        // Get Ethereum provider and signer
        if (!window.ethereum) {
          throw new Error('No Ethereum provider found');
        }
        
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();
        const address = await signer.getAddress();
        
        // Use a sample counterparty address and token
        const participantA = address;
        const participantB = '0xOtherAddress';
        const amount = '1000000'; // 1 USDC with 6 decimals
            
        // Define app session parameters
        const appDefinition = {
          protocol: 'nitroliterpc',
          participants: [participantA, participantB],
          weights: [100, 0],
          quorum: 100,
          challenge: 0,
          nonce: Date.now(),
        };
        
        
        
        // Message signer function
        const messageSigner = async (payload) => {
          const message = JSON.stringify(payload);
          const digestHex = ethers.id(message);
          const messageBytes = ethers.getBytes(digestHex);
          return await signer.signMessage(messageBytes);
        };
        
        // Define allocations with asset type
        const allocations = [
          {
            participant: participantA,
            asset: 'usdc',
            amount: amount,
          },
          {
            participant: participantB,
            asset: 'usdc',
            amount: '0',
          },
        ];
        
        // Create signed message
        const signedMessage = await createAppSessionMessage(
          messageSigner,
          [
            {
              definition: appDefinition,
              allocations: allocations,
            },
          ]
        );
        
        // Send message and handle response
        const response = await sendWebSocketRequest(signedMessage);
        
        if (response.success && response.app_session_id) {
          appId.value = response.app_session_id;
          localStorage.setItem('app_session_id', response.app_session_id);
          console.log('Application session created successfully:', response.app_session_id);
        } else {
          console.warn('Session created but no app_session_id returned:', response);
        }
      } catch (err) {
        error.value = err.message || 'Error creating application session';
        console.error('Failed to create application session:', err);
      } finally {
        isCreating.value = false;
      }
    };
    
    const sendWebSocketRequest = (payload) => {
      return new Promise((resolve, reject) => {
        const handleMessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            
            if (message.res && message.res[1] === 'create_app_session') {
              webSocket.removeEventListener('message', handleMessage);
              
              const appSessionId = message.res[2]?.[0]?.app_session_id;
              const status = message.res[2]?.[0]?.status || "open";
              resolve({
                success: true,
                app_session_id: appSessionId,
                status: status,
                response: message.res[2]
              });
            }
            
            if (message.err) {
              webSocket.removeEventListener('message', handleMessage);
              reject(new Error(`Error: ${message.err[1]} - ${message.err[2]}`));
            }
          } catch (error) {
            console.error('Error parsing message:', error);
          }
        };
        
        webSocket.addEventListener('message', handleMessage);
        webSocket.send(payload);
        
        // Set timeout to prevent hanging
        setTimeout(() => {
          webSocket.removeEventListener('message', handleMessage);
          reject(new Error('App session creation timeout'));
        }, 10000);
      });
    };
    
    return {
      appId,
      isCreating,
      error,
      isConnected,
      createAppSession
    };
  }
});
</script>

<style scoped>
.app-session-manager {
  padding: 20px;
  border: 1px solid #eee;
  border-radius: 8px;
  margin-bottom: 20px;
}
.current-session {
  margin-bottom: 15px;
  padding: 10px;
  background-color: #f5f5f5;
  border-radius: 4px;
}
.error-message {
  color: #d32f2f;
  margin-top: 10px;
}
.warning-message {
  color: #f57c00;
  margin-top: 10px;
}
button {
  padding: 8px 16px;
  background-color: #1976d2;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
button:disabled {
  background-color: #bbdefb;
  cursor: not-allowed;
}
</style>
```

  </TabItem>
  <TabItem value="nodejs" label="Node.js">

```javascript
import { createAppSessionMessage } from '@erc7824/nitrolite';
import WebSocket from 'ws';
import { ethers } from 'ethers';

/**
 * Create an app session
 * @param {string} participantA - First participant's address
 * @param {string} participantB - Second participant's address
 * @param {WebSocket} ws - WebSocket connection to the ClearNode
 * @param {object} wallet - Ethers wallet for signing
 * @returns {Promise<string>} The app session ID
 */
async function createAppSession(participantA, participantB, ws, wallet) {
  try {
    console.log(`Creating app session between ${participantA} and ${participantB}`);
    
    // Message signer function
    const messageSigner = async (payload) => {
      try {
        const message = JSON.stringify(payload);
        const digestHex = ethers.id(message);
        const messageBytes = ethers.getBytes(digestHex);
        const { serialized: signature } = wallet.signingKey.sign(messageBytes);
        return signature;
      } catch (error) {
        console.error("Error signing message:", error);
        throw error;
      }
    };
    
    // Create app definition
    const appDefinition = {
      protocol: "nitroliterpc",
      participants: [participantA, participantB],
      weights: [100, 0],
      quorum: 100,
      challenge: 0,
      nonce: Date.now(),
    };
    
    // Define the allocations with asset type (e.g., 1 USDC with 6 decimals)
    const amount = '1000000';
    
    // Define allocations
    const allocations = [
      {
        participant: participantA,
        asset: 'usdc',
        amount: amount,
      },
      {
        participant: participantB,
        asset: 'usdc',
        amount: '0',
      },
    ];
    
    // Create the signed message
    const signedMessage = await createAppSessionMessage(
      messageSigner,
      [
        {
          definition: appDefinition,
          allocations: allocations,
        },
      ]
    );
    
    // Send the message and wait for response
    return new Promise((resolve, reject) => {
      // Create a one-time message handler for the app session response
      const handleAppSessionResponse = (data) => {
        try {
          const rawData = typeof data === 'string' ? data : data.toString();
          const message = JSON.parse(rawData);
          
          console.log('Received app session creation response:', message);
          
          // Check if this is an app session response
          if (message.res && 
              (message.res[1] === 'create_app_session' || 
               message.res[1] === 'app_session_created')) {
            // Remove the listener once we get the response
            ws.removeListener('message', handleAppSessionResponse);
            
            // Extract app session ID from response
            const appSessionId = message.res[2]?.[0]?.app_session_id;
            if (!appSessionId) {
              reject(new Error('Failed to get app session ID from response'));
              return;
            }
            
            resolve(appSessionId);
          }
          
          // Check for error responses
          if (message.err) {
            ws.removeListener('message', handleAppSessionResponse);
            reject(new Error(`Error ${message.err[1]}: ${message.err[2]}`));
          }
        } catch (error) {
          console.error('Error handling app session response:', error);
        }
      };
      
      // Add the message handler
      ws.on('message', handleAppSessionResponse);
      
      // Set timeout to prevent hanging
      setTimeout(() => {
        ws.removeListener('message', handleAppSessionResponse);
        reject(new Error('App session creation timeout'));
      }, 10000);
      
      // Send the signed message
      ws.send(signedMessage);
    });
  } catch (error) {
    console.error('Error creating app session:', error);
    throw error;
  }
}

// Usage example
const participantA = '0x1234...';  // Your address
const participantB = '0x5678...';  // Other participant's address

// Assuming you have a WebSocket connection and wallet initialized
createAppSession(participantA, participantB, ws, wallet)
  .then(appSessionId => {
    console.log(`Application session created with ID: ${appSessionId}`);
    // Store the app session ID for future reference
  })
  .catch(error => {
    console.error('Failed to create application session:', error);
  });
```

  </TabItem>
  <TabItem value="server" label="Server with Multiple Players">

```javascript
/**
 * Nitrolite app sessions manager for game rooms
 */
import { createAppSessionMessage } from '@erc7824/nitrolite';
import { ethers } from 'ethers';

// Map to store app sessions by room ID
const roomAppSessions = new Map();

/**
 * Create an app session for a game room
 * @param {string} roomId - Room ID
 * @param {string} participantA - First player's address
 * @param {string} participantB - Second player's address
 * @param {WebSocket} ws - WebSocket connection to the ClearNode
 * @param {object} wallet - Ethers wallet for signing
 * @returns {Promise<string>} The app session ID
 */
export async function createAppSession(roomId, participantA, participantB, ws, wallet) {
  try {
    console.log(`Creating app session for room ${roomId}`);
    
    // Get the server's address
    const serverAddress = wallet.address;
    
    // Create app definition with server as a participant
    // In this setup, the server acts as a referee/facilitator
    const appDefinition = {
      protocol: "app_nitrolite_v0",
      participants: [participantA, participantB, serverAddress],
      weights: [0, 0, 100],  // Server has full control
      quorum: 100,
      challenge: 0,
      nonce: Date.now(),
    };
    
    // Define allocations with asset type
    const allocations = [
      {
        participant: participantA,
        asset: 'usdc',
        amount: '0',
      },
      {
        participant: participantB,
        asset: 'usdc',
        amount: '0',
      },
      {
        participant: serverAddress,
        asset: 'usdc',
        amount: '0',
      },
    ];
    
    // Message signer function
    const messageSigner = async (payload) => {
      try {
        const message = JSON.stringify(payload);
        const digestHex = ethers.id(message);
        const messageBytes = ethers.getBytes(digestHex);
        const { serialized: signature } = wallet.signingKey.sign(messageBytes);
        return signature;
      } catch (error) {
        console.error("Error signing message:", error);
        throw error;
      }
    };
    
    // Create the signed message
    const signedMessage = await createAppSessionMessage(
      messageSigner,
      [
        {
          definition: appDefinition,
          allocations: allocations,
        },
      ]
    );
    
    // Send the message and wait for response
    return new Promise((resolve, reject) => {
      // Create a one-time message handler for the app session response
      const handleAppSessionResponse = (data) => {
        try {
          const rawData = typeof data === 'string' ? data : data.toString();
          const message = JSON.parse(rawData);
          
          console.log('Received app session creation response:', message);
          
          // Check if this is an app session response
          if (message.res && 
              (message.res[1] === 'create_app_session' || 
               message.res[1] === 'app_session_created')) {
            // Remove the listener once we get the response
            ws.removeListener('message', handleAppSessionResponse);
            
            // Extract app session ID from response
            const appSessionId = message.res[2]?.[0]?.app_session_id;
            if (!appSessionId) {
              reject(new Error('Failed to get app session ID from response'));
              return;
            }
            
            // Get status from response
            const status = message.res[2]?.[0]?.status || "open";
            
            // Store the app session for this room
            roomAppSessions.set(roomId, {
              appSessionId,
              status,
              participantA,
              participantB,
              serverAddress,
              createdAt: Date.now()
            });
            
            resolve(appSessionId);
          }
          
          // Check for error responses
          if (message.err) {
            ws.removeListener('message', handleAppSessionResponse);
            reject(new Error(`Error ${message.err[1]}: ${message.err[2]}`));
          }
        } catch (error) {
          console.error('Error handling app session response:', error);
        }
      };
      
      // Add the message handler
      ws.on('message', handleAppSessionResponse);
      
      // Set timeout to prevent hanging
      setTimeout(() => {
        ws.removeListener('message', handleAppSessionResponse);
        reject(new Error('App session creation timeout'));
      }, 10000);
      
      // Send the signed message
      ws.send(signedMessage);
    });
  } catch (error) {
    console.error(`Error creating app session for room ${roomId}:`, error);
    throw error;
  }
}

/**
 * Get the app session for a room
 * @param {string} roomId - Room ID
 * @returns {Object|null} The app session or null if not found
 */
export function getAppSession(roomId) {
  return roomAppSessions.get(roomId) || null;
}

/**
 * Check if a room has an app session
 * @param {string} roomId - Room ID
 * @returns {boolean} Whether the room has an app session
 */
export function hasAppSession(roomId) {
  return roomAppSessions.has(roomId);
}
```

  </TabItem>
</Tabs>

## Key Components of an Application Session

When creating an application session, you need to define several key components:

| Component | Description | Example |
|-----------|-------------|---------|
| **Protocol** | Identifier for the application protocol | `"nitroliterpc"` |
| **Participants** | Array of participant addresses | `[userAddress, counterpartyAddress]` |
| **Weights** | Weight distribution for consensus | `[100, 0]` for user-controlled, `[50, 50]` for equal |
| **Quorum** | Required percentage for consensus | Usually `100` for full consensus |
| **Challenge** | Time period for disputing state | `0` for no challenge period |
| **Nonce** | Unique identifier | Typically `Date.now()` |
| **Allocations** | Array of allocation objects with: | `[{ participant: "0xAddress", asset: "usdc", amount: "100" }]` |
|            | - participant: Address of the participant | |
|            | - asset: Asset identifier (e.g., "usdc", "eth") | |
|            | - amount: String amount with precision | |

### Response Components

When a ClearNode responds to your application session creation request, it provides:

| Component | Description | Example |
|-----------|-------------|---------|
| **app_session_id** | Unique identifier for the application session | `"0x0ac588b2924edbbbe34bb4c51d089771bd7bd7018136c8c4317624112a8c9f79"` |
| **status** | Current state of the application session | `"open"` |

## Understanding the Response

When you create an application session, the ClearNode responds with information about the created session:

```javascript
// Example response
{
  "res": [
    2,                // Request ID
    "create_app_session", // Method name
    [
      {
        "app_session_id": "0x0ac588b2924edbbbe34bb4c51d089771bd7bd7018136c8c4317624112a8c9f79", // Session ID
        "status": "open"
      }
    ],
    1631234567890    // Timestamp
  ],
  "sig": ["0xSignature"]
}
```

The most important part of the response is the `app_session_id`, which you'll need for all future interactions with this application session.

## Application Session Use Cases

Application sessions can be used for various scenarios:

1. **Peer-to-peer payments**: Direct token transfers between users
2. **Gaming**: Turn-based games with state transitions
3. **Content access**: Pay-per-use access to digital content
4. **Service payments**: Metered payment for API or service usage
5. **Multi-party applications**: Applications involving more than two participants

## Best Practices

When working with application sessions, follow these best practices:

1. **Store the app_session_id securely**: You'll need it for all session-related operations
2. **Verify session creation**: Check for successful creation before proceeding
3. **Handle timeouts**: Implement proper timeout handling for session creation
4. **Clean up listeners**: Always remove message event listeners to prevent memory leaks
5. **Handle errors gracefully**: Provide clear error messages to users

## Next Steps

After creating an application session, you can:

1. Use the session for application-specific transactions
2. [Check your channel balances](balances) to monitor funds
3. [Close the application session](close_session) when you're done

For advanced use cases, see our detailed documentation on application workflows.

---

---
sidebar_position: 8
title: Close Application Session
description: Properly close application sessions and finalize fund allocations using NitroliteRPC.
keywords: [erc7824, nitrolite, close session, finalize, state channels]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Close Application Session

Once you've completed your interactions with an application session, it's important to properly close it. This finalizes the fund allocations and ensures that all participants agree on the final state.

## Why Properly Closing Sessions Matters

Closing an application session correctly is important because it:

- Finalizes fund allocations between participants
- Updates on-chain balances (if applicable)
- Frees up resources on the ClearNode
- Ensures the proper completion of all operations
- Prevents potential disputes

## Closing an Application Session

To close an application session, you'll use the `createCloseAppSessionMessage` helper from NitroliteRPC. Here's how to do it:

<Tabs>
  <TabItem value="react" label="React">

```javascript
import { useCallback } from 'react';
import { createCloseAppSessionMessage } from '@erc7824/nitrolite';

/**
 * Hook for closing an application session
 */
function useCloseApplicationSession() {
  const closeApplicationSession = useCallback(
    async (
      signer,
      sendRequest,
      appId,
      participantA,
      participantB,
      amount
    ) => {
      try {
        if (!appId) {
          throw new Error('Application ID is required to close the session.');
        }
        
        // Create allocations with asset type
        const allocations = [
          {
            participant: participantA,
            asset: 'usdc',
            amount: '0',
          },
          {
            participant: participantB,
            asset: 'usdc',
            amount: amount,
          },
        ];
        
        // Create the close request
        const closeRequest = {
          app_session_id: appId,
          allocations: allocations,
        };
        
        // Create the signed message
        const signedMessage = await createCloseAppSessionMessage(
          signer.sign, 
          [closeRequest]
        );
        
        // Send the request and wait for response
        const response = await sendRequest(signedMessage);
        
        // Check for success
        if (response && response[0] && response[0].app_session_id) {
          // Clean up local storage
          localStorage.removeItem('app_session_id');
          return { 
            success: true, 
            app_id: response[0].app_session_id,
            status: response[0].status || "closed", 
            response 
          };
        } else {
          return { success: true, response };
        }
      } catch (error) {
        console.error('Error closing application session:', error);
        return {
          success: false,
          error: error instanceof Error
            ? error.message
            : 'Unknown error during close session',
        };
      }
    },
    []
  );
  
  return { closeApplicationSession };
}

// Usage example
function MyComponent() {
  const { closeApplicationSession } = useCloseApplicationSession();
  
  const handleCloseSession = async () => {
    // Define your WebSocket send wrapper
    const sendRequest = async (payload) => {
      return new Promise((resolve, reject) => {
        // Assuming ws is your WebSocket connection
        const handleMessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            if (message.res && message.res[1] === 'close_app_session') {
              ws.removeEventListener('message', handleMessage);
              resolve(message.res[2]);
            }
          } catch (error) {
            console.error('Error parsing message:', error);
          }
        };
        
        ws.addEventListener('message', handleMessage);
        ws.send(payload);
        
        // Set timeout to prevent hanging
        setTimeout(() => {
          ws.removeEventListener('message', handleMessage);
          reject(new Error('Close app session timeout'));
        }, 10000);
      });
    };
    
    // Get the app session ID from where it was stored
    const appId = localStorage.getItem('app_session_id');
    
    // Define participant addresses
    const participantA = '0xYourAddress';
    const participantB = '0xOtherAddress';
    
    // Define amount
    const amount = '1000000'; // Amount to allocate to participantB
    
    const result = await closeApplicationSession(
      walletSigner,      // Your signer object
      sendRequest,       // Function to send the request
      appId,             // Application session ID
      participantA,      // First participant address
      participantB,      // Second participant address
      amount             // Amount to allocate to participant B
    );
    
    if (result.success) {
      console.log('Application session closed successfully');
    } else {
      console.error(`Failed to close application session: ${result.error}`);
    }
  };
  
  return (
    <button onClick={handleCloseSession}>Close Application Session</button>
  );
}
```

  </TabItem>
  <TabItem value="angular" label="Angular">

```typescript
// app-session.service.ts
import { Injectable } from '@angular/core';
import { createCloseAppSessionMessage } from '@erc7824/nitrolite';
import { ethers } from 'ethers';
import { BehaviorSubject, Observable, from } from 'rxjs';
import { tap, catchError } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class AppSessionService {
  private webSocket: WebSocket | null = null;
  private appIdSubject = new BehaviorSubject<string | null>(null);
  
  public appId$ = this.appIdSubject.asObservable();
  
  constructor() {
    // Retrieve app ID from storage if available
    const storedAppId = localStorage.getItem('app_session_id');
    if (storedAppId) {
      this.appIdSubject.next(storedAppId);
    }
  }
  
  public setWebSocket(ws: WebSocket): void {
    this.webSocket = ws;
  }
  
  // This method closes an application session
  public closeApplicationSession(
    signer: any,
    appId: string,
    finalAllocations: number[]
  ): Observable<any> {
    if (!this.webSocket) {
      throw new Error('WebSocket connection is not established');
    }
    
    if (!appId) {
      throw new Error('Application ID is required');
    }
    
    return from(this.closeAppSessionAsync(
      signer,
      appId,
      participantA,
      participantB,
      amount
    )).pipe(
      tap(result => {
        if (result.success) {
          // Remove app ID from storage
          localStorage.removeItem('app_session_id');
          this.appIdSubject.next(null);
        }
      }),
      catchError(error => {
        console.error('Error closing application session:', error);
        throw error;
      })
    );
  }
  
  private async closeAppSessionAsync(
    signer: any,
    appId: string,
    participantA: string,
    participantB: string,
    amount: string
  ): Promise<any> {
    try {
      // Create allocations with asset type
      const allocations = [
        {
          participant: participantA,
          asset: 'usdc',
          amount: '0',
        },
        {
          participant: participantB,
          asset: 'usdc',
          amount: amount,
        },
      ];
      
      // Create close request
      const closeRequest = {
        app_session_id: appId,
        allocations: allocations,
      };
      
      
      // Create message signer function
      const messageSigner = async (payload: any) => {
        const message = JSON.stringify(payload);
        const digestHex = ethers.id(message);
        const messageBytes = ethers.getBytes(digestHex);
        const signature = await signer.signMessage(messageBytes);
        return signature;
      };
      
      // Create the signed message
      const signedMessage = await createCloseAppSessionMessage(
        messageSigner,
        [closeRequest]
      );
      
      // Send the message and wait for response
      return await this.sendRequest(signedMessage);
    } catch (error) {
      console.error('Error in closeAppSessionAsync:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }
  
  private sendRequest(payload: string): Promise<any> {
    return new Promise((resolve, reject) => {
      if (!this.webSocket) {
        reject(new Error('WebSocket not connected'));
        return;
      }
      
      const handleMessage = (event: MessageEvent) => {
        try {
          const message = JSON.parse(event.data);
          if (message.res && message.res[1] === 'close_app_session') {
            this.webSocket?.removeEventListener('message', handleMessage);
            resolve({
              success: true,
              app_id: message.res[2]?.[0]?.app_session_id || null,
              status: message.res[2]?.[0]?.status || "closed",
              response: message.res[2]
            });
          }
          
          if (message.err) {
            this.webSocket?.removeEventListener('message', handleMessage);
            reject(new Error(`Error: ${message.err[1]} - ${message.err[2]}`));
          }
        } catch (error) {
          console.error('Error parsing message:', error);
        }
      };
      
      this.webSocket.addEventListener('message', handleMessage);
      this.webSocket.send(payload);
      
      // Set timeout to prevent hanging
      setTimeout(() => {
        this.webSocket?.removeEventListener('message', handleMessage);
        reject(new Error('Close session timeout'));
      }, 10000);
    });
  }
}

// app-session-close.component.ts
import { Component, OnInit } from '@angular/core';
import { AppSessionService } from './app-session.service';

@Component({
  selector: 'app-session-closer',
  template: `
    <div class="app-session-container">
      <h3>Close Application Session</h3>
      <div *ngIf="appId">
        Current Application Session ID: {{ appId }}
        
        <div class="allocation-controls">
          <div class="allocation-item">
            <label>Your allocation:</label>
            <input type="number" [(ngModel)]="allocation1" min="0" max="1000000">
          </div>
          <div class="allocation-item">
            <label>Counterparty allocation:</label>
            <input type="number" [(ngModel)]="allocation2" min="0" max="1000000">
          </div>
        </div>
        
        <button (click)="closeAppSession()" [disabled]="isClosing">
          {{ isClosing ? 'Closing...' : 'Close Application Session' }}
        </button>
      </div>
      
      <div *ngIf="!appId" class="info-message">
        No active application session found.
      </div>
      
      <div *ngIf="error" class="error-message">
        {{ error }}
      </div>
      
      <div *ngIf="success" class="success-message">
        Application session closed successfully!
      </div>
    </div>
  `,
  styles: [`
    .app-session-container {
      margin: 20px;
      padding: 15px;
      border: 1px solid #eee;
      border-radius: 5px;
    }
    .allocation-controls {
      margin: 15px 0;
    }
    .allocation-item {
      margin-bottom: 10px;
    }
    .error-message {
      color: red;
      margin-top: 10px;
    }
    .success-message {
      color: green;
      margin-top: 10px;
    }
    .info-message {
      color: blue;
      margin-top: 10px;
    }
  `]
})
export class AppSessionCloseComponent implements OnInit {
  appId: string | null = null;
  isClosing = false;
  error: string | null = null;
  success = false;
  
  // Default allocations (e.g., 800000 / 200000 split for 1 USDC)
  allocation1 = 800000;
  allocation2 = 200000;
  
  constructor(private appSessionService: AppSessionService) {}
  
  ngOnInit(): void {
    // Subscribe to app ID changes
    this.appSessionService.appId$.subscribe(id => {
      this.appId = id;
      this.success = false;
    });
  }
  
  closeAppSession(): void {
    if (!this.appId) {
      this.error = 'No active application session';
      return;
    }
    
    this.isClosing = true;
    this.error = null;
    this.success = false;
    
    // Define participants
    const participantA = '0xYourAddress';
    const participantB = '0xOtherAddress';
    
    // Create allocations with asset type
    const amount = this.allocation2.toString();
    
    // Assuming you have access to a signer (e.g., from MetaMask)
    const signer = window.ethereum && new ethers.providers.Web3Provider(window.ethereum).getSigner();
    
    if (!signer) {
      this.error = 'No wallet connected';
      this.isClosing = false;
      return;
    }
    
    this.appSessionService.closeApplicationSession(
      signer,
      this.appId,
      participantA,
      participantB,
      amount
    ).subscribe({
      next: (result) => {
        console.log('App session closed:', result);
        this.success = true;
        this.isClosing = false;
      },
      error: (err) => {
        this.error = `Failed to close application session: ${err.message}`;
        this.isClosing = false;
      }
    });
  }
}
```

  </TabItem>
  <TabItem value="vue" label="Vue.js">

```javascript
<!-- AppSessionClose.vue -->
<template>
  <div class="app-session-closer">
    <h3>Close Application Session</h3>
    
    <div v-if="appId" class="active-session">
      <p>Active session ID: {{ appId }}</p>
      
      <div class="allocation-controls">
        <div class="allocation-item">
          <label>Your allocation:</label>
          <input 
            type="number" 
            v-model.number="allocation1" 
            min="0" 
            :max="totalAmount"
            @input="updateAllocation2"
          />
        </div>
        
        <div class="allocation-item">
          <label>Counterparty allocation:</label>
          <input 
            type="number" 
            v-model.number="allocation2" 
            min="0" 
            :max="totalAmount"
            @input="updateAllocation1"
          />
        </div>
        
        <div class="total-info">
          <p>Total: {{ totalAmount }} (should match initial funding)</p>
        </div>
      </div>
      
      <button 
        @click="closeAppSession" 
        :disabled="isClosing || !isConnected"
      >
        {{ isClosing ? 'Closing Session...' : 'Close Application Session' }}
      </button>
    </div>
    
    <div v-else class="no-session">
      <p>No active application session found.</p>
    </div>
    
    <div v-if="error" class="error-message">
      {{ error }}
    </div>
    
    <div v-if="success" class="success-message">
      Application session closed successfully!
    </div>
    
    <div v-if="!isConnected" class="warning-message">
      WebSocket not connected to ClearNode
    </div>
  </div>
</template>

<script>
import { defineComponent, ref, computed, onMounted, onUnmounted } from 'vue';
import { createCloseAppSessionMessage } from '@erc7824/nitrolite';
import { ethers } from 'ethers';

export default defineComponent({
  name: 'AppSessionClose',
  
  setup() {
    const appId = ref(localStorage.getItem('app_session_id') || null);
    const isClosing = ref(false);
    const error = ref(null);
    const success = ref(false);
    const isConnected = ref(false);
    let webSocket = null;
    
    // Allocations for final distribution
    const totalAmount = ref(1000000); // 1 USDC with 6 decimals
    const allocation1 = ref(800000);  // 0.8 USDC to participant A
    const allocation2 = ref(200000);  // 0.2 USDC to participant B
    
    // Update allocation2 when allocation1 changes
    const updateAllocation2 = () => {
      allocation2.value = totalAmount.value - allocation1.value;
    };
    
    // Update allocation1 when allocation2 changes
    const updateAllocation1 = () => {
      allocation1.value = totalAmount.value - allocation2.value;
    };
    
    onMounted(() => {
      // Initialize WebSocket connection
      initWebSocket();
    });
    
    onUnmounted(() => {
      // Clean up WebSocket connection
      if (webSocket) {
        webSocket.close();
      }
    });
    
    const initWebSocket = () => {
      webSocket = new WebSocket('wss://your-clearnode-endpoint');
      
      webSocket.onopen = () => {
        isConnected.value = true;
        console.log('WebSocket connected to ClearNode');
      };
      
      webSocket.onclose = () => {
        isConnected.value = false;
        console.log('WebSocket disconnected from ClearNode');
      };
      
      webSocket.onerror = (e) => {
        isConnected.value = false;
        error.value = 'WebSocket connection error';
        console.error('WebSocket error:', e);
      };
    };
    
    const closeAppSession = async () => {
      if (!isConnected.value || !webSocket) {
        error.value = 'WebSocket not connected';
        return;
      }
      
      if (!appId.value) {
        error.value = 'No application session ID found';
        return;
      }
      
      try {
        isClosing.value = true;
        error.value = null;
        success.value = false;
        
        // Get Ethereum provider and signer
        if (!window.ethereum) {
          throw new Error('No Ethereum provider found');
        }
        
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();
        
        // Create the close request
        const closeRequest = {
          app_id: appId.value,
          allocations: [allocation1.value, allocation2.value],
        };
        
        // Final intent matches allocations
        const finalIntent = [allocation1.value, allocation2.value];
        
        // Message signer function
        const messageSigner = async (payload) => {
          const message = JSON.stringify(payload);
          const digestHex = ethers.id(message);
          const messageBytes = ethers.getBytes(digestHex);
          return await signer.signMessage(messageBytes);
        };
        
        // Create signed message
        const signedMessage = await createCloseAppSessionMessage(
          messageSigner,
          [closeRequest],
          finalIntent
        );
        
        // Send message and handle response
        const response = await sendWebSocketRequest(signedMessage);
        
        if (response.success) {
          // Clean up local storage
          localStorage.removeItem('app_session_id');
          appId.value = null;
          success.value = true;
        } else {
          error.value = response.error || 'Unknown error during close';
        }
      } catch (err) {
        error.value = err.message || 'Error closing application session';
        console.error('Failed to close application session:', err);
      } finally {
        isClosing.value = false;
      }
    };
    
    const sendWebSocketRequest = (payload) => {
      return new Promise((resolve, reject) => {
        const handleMessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            
            if (message.res && message.res[1] === 'close_app_session') {
              webSocket.removeEventListener('message', handleMessage);
              
              resolve({
                success: true,
                app_id: message.res[2]?.[0]?.app_session_id || null,
                status: message.res[2]?.[0]?.status || "closed",
                response: message.res[2]
              });
            }
            
            if (message.err) {
              webSocket.removeEventListener('message', handleMessage);
              reject(new Error(`Error: ${message.err[1]} - ${message.err[2]}`));
            }
          } catch (error) {
            console.error('Error parsing message:', error);
          }
        };
        
        webSocket.addEventListener('message', handleMessage);
        webSocket.send(payload);
        
        // Set timeout to prevent hanging
        setTimeout(() => {
          webSocket.removeEventListener('message', handleMessage);
          reject(new Error('Close app session timeout'));
        }, 10000);
      });
    };
    
    return {
      appId,
      isClosing,
      error,
      success,
      isConnected,
      totalAmount,
      allocation1,
      allocation2,
      updateAllocation1,
      updateAllocation2,
      closeAppSession
    };
  }
});
</script>

<style scoped>
.app-session-closer {
  padding: 20px;
  border: 1px solid #eee;
  border-radius: 8px;
  margin-bottom: 20px;
}
.active-session {
  margin-bottom: 15px;
}
.allocation-controls {
  margin: 20px 0;
  padding: 15px;
  background-color: #f5f5f5;
  border-radius: 4px;
}
.allocation-item {
  margin-bottom: 10px;
  display: flex;
  align-items: center;
}
.allocation-item label {
  width: 200px;
  margin-right: 10px;
}
.allocation-item input {
  width: 150px;
  padding: 5px;
  border: 1px solid #ccc;
  border-radius: 4px;
}
.total-info {
  margin-top: 10px;
  font-weight: bold;
}
.error-message {
  color: #d32f2f;
  margin-top: 10px;
}
.success-message {
  color: #388e3c;
  margin-top: 10px;
}
.warning-message {
  color: #f57c00;
  margin-top: 10px;
}
button {
  padding: 8px 16px;
  background-color: #1976d2;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
button:disabled {
  background-color: #bbdefb;
  cursor: not-allowed;
}
</style>
```

  </TabItem>
  <TabItem value="nodejs" label="Node.js">

```javascript
import { createCloseAppSessionMessage } from '@erc7824/nitrolite';
import { ethers } from 'ethers';

/**
 * Close an app session
 * @param {string} appId - The app session ID to close
 * @param {string} participantA - First participant's address
 * @param {string} participantB - Second participant's address
 * @param {string} amount - Amount to allocate to participant B
 * @param {WebSocket} ws - WebSocket connection to the ClearNode
 * @param {object} wallet - Ethers wallet for signing
 * @returns {Promise<boolean>} Success status
 */
async function closeAppSession(appId, participantA, participantB, amount, ws, wallet) {
  try {
    console.log(`Closing app session ${appId} with amount ${amount}`);
    
    if (!appId) {
      throw new Error('App session ID is required to close the session');
    }
    
    // Message signer function
    const messageSigner = async (payload) => {
      try {
        const message = JSON.stringify(payload);
        const digestHex = ethers.id(message);
        const messageBytes = ethers.getBytes(digestHex);
        const { serialized: signature } = wallet.signingKey.sign(messageBytes);
        return signature;
      } catch (error) {
        console.error("Error signing message:", error);
        throw error;
      }
    };
    
    // Create allocations with asset type
    const allocations = [
      {
        participant: participantA,
        asset: 'usdc',
        amount: '0',
      },
      {
        participant: participantB,
        asset: 'usdc',
        amount: amount,
      },
    ];
    
    // Create the close request
    const closeRequest = {
      app_session_id: appId,
      allocations: allocations,
    };
    
    // Create the signed message
    const signedMessage = await createCloseAppSessionMessage(
      messageSigner, 
      [closeRequest]
    );
    
    // Send the message and wait for response
    return new Promise((resolve, reject) => {
      // Create a one-time message handler for the close session response
      const handleCloseSessionResponse = (data) => {
        try {
          const rawData = typeof data === 'string' ? data : data.toString();
          const message = JSON.parse(rawData);
          
          console.log('Received close session response:', message);
          
          // Check if this is a close session response
          if (message.res && 
              (message.res[1] === 'close_app_session' || 
               message.res[1] === 'app_session_closed')) {
            // Remove the listener once we get the response
            ws.removeListener('message', handleCloseSessionResponse);
            
            // Extract app ID and status from response
            const appId = message.res[2]?.[0]?.app_id;
            const status = message.res[2]?.[0]?.status || "closed";
            
            resolve({
              success: true,
              app_session_id: appId,
              status: status
            });
          }
          
          // Check for error responses
          if (message.err) {
            ws.removeListener('message', handleCloseSessionResponse);
            reject(new Error(`Error ${message.err[1]}: ${message.err[2]}`));
          }
        } catch (error) {
          console.error('Error handling close session response:', error);
        }
      };
      
      // Add the message handler
      ws.on('message', handleCloseSessionResponse);
      
      // Set timeout to prevent hanging
      setTimeout(() => {
        ws.removeListener('message', handleCloseSessionResponse);
        reject(new Error('Close session timeout'));
      }, 10000);
      
      // Send the signed message
      ws.send(signedMessage);
    });
  } catch (error) {
    console.error(`Error closing app session ${appId}:`, error);
    throw error;
  }
}

// Usage example
const appId = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
const participantA = '0x1234...';  // Your address
const participantB = '0x5678...';  // Other participant's address
const amount = '200000'; // 0.2 USDC to participant B

// Assuming you have a WebSocket connection and wallet initialized
closeAppSession(appId, participantA, participantB, amount, ws, wallet)
  .then(result => {
    if (result.success) {
      console.log(`Application session ${result.app_id} closed successfully with status: ${result.status}`);
    }
  })
  .catch(error => {
    console.error('Failed to close application session:', error);
  });
```

  </TabItem>
  <TabItem value="server" label="Server with Multiple Players">

```javascript
/**
 * Close an app session for a game room
 * @param {string} roomId - Room ID
 * @param {Array<number>} allocations - Final allocations [player1, player2, server]
 * @param {WebSocket} ws - WebSocket connection to the ClearNode
 * @param {object} wallet - Ethers wallet for signing
 * @returns {Promise<boolean>} Success status
 */
export async function closeAppSession(roomId, participantA, participantB, participantServer, amount, ws, wallet) {
  try {
    // Get the app session for this room
    const appSession = roomAppSessions.get(roomId);
    if (!appSession) {
      console.warn(`No app session found for room ${roomId}`);
      return false;
    }
    
    // Make sure appSessionId exists
    const appSessionId = appSession.appSessionId;
    if (!appSessionId) {
      console.error(`No appSessionId found in app session for room ${roomId}`);
      return false;
    }
    
    console.log(`Closing app session ${appSessionId} for room ${roomId}`);
    
    // Message signer function
    const messageSigner = async (payload) => {
      try {
        const message = JSON.stringify(payload);
        const digestHex = ethers.id(message);
        const messageBytes = ethers.getBytes(digestHex);
        const { serialized: signature } = wallet.signingKey.sign(messageBytes);
        return signature;
      } catch (error) {
        console.error("Error signing message:", error);
        throw error;
      }
    };
    
    // Create allocations with asset type
    const allocations = [
      {
        participant: participantA,
        asset: 'usdc',
        amount: '0',
      },
      {
        participant: participantB,
        asset: 'usdc',
        amount: amount,
      },
      {
        participant: participantServer,
        asset: 'usdc',
        amount: '0',
      },
    ];
    
    // Create close request
    const closeRequest = {
      app_session_id: appSessionId,
      allocations: allocations,
    };
    
    // Create the signed message
    const signedMessage = await createCloseAppSessionMessage(
      messageSigner, 
      [closeRequest]
    );
    
    // Send the message and wait for response
    return new Promise((resolve, reject) => {
      // Create a one-time message handler for the close session response
      const handleCloseSessionResponse = (data) => {
        try {
          const rawData = typeof data === 'string' ? data : data.toString();
          const message = JSON.parse(rawData);
          
          console.log('Received close session response:', message);
          
          // Check if this is a close session response
          if (message.res && 
              (message.res[1] === 'close_app_session' || 
               message.res[1] === 'app_session_closed')) {
            // Remove the listener once we get the response
            ws.removeListener('message', handleCloseSessionResponse);
            
            // Extract app ID and status from response
            const appId = message.res[2]?.[0]?.app_id;
            const status = message.res[2]?.[0]?.status || "closed";
            
            // Remove the app session
            roomAppSessions.delete(roomId);
            
            resolve({
              success: true,
              app_session_id: appId,
              status: status,
              roomId: roomId
            });
          }
          
          // Check for error responses
          if (message.err) {
            ws.removeListener('message', handleCloseSessionResponse);
            reject(new Error(`Error ${message.err[1]}: ${message.err[2]}`));
          }
        } catch (error) {
          console.error('Error handling close session response:', error);
        }
      };
      
      // Add the message handler
      ws.on('message', handleCloseSessionResponse);
      
      // Set timeout to prevent hanging
      setTimeout(() => {
        ws.removeListener('message', handleCloseSessionResponse);
        reject(new Error('Close session timeout'));
      }, 10000);
      
      // Send the signed message
      ws.send(signedMessage);
    });
  } catch (error) {
    console.error(`Error closing app session for room ${roomId}:`, error);
    return false;
  }
}
```

  </TabItem>
</Tabs>

## Understanding Final Allocations

When closing an application session, you must specify the final allocations of funds between participants:

- **Final Allocations**: An array of allocation objects for each participant
- **Participant**: The address of the participant receiving funds
- **Asset**: The asset type (e.g., "usdc", "eth")
- **Amount**: The amount as a string (e.g., "1000000" or "0.5")

Examples:

```javascript
// Initial allocations when creating the session:
// [
//   { participant: participantA, asset: "usdc", amount: "1000000" },
//   { participant: participantB, asset: "usdc", amount: "0" }
// ]

// Possible final allocations when closing:
const allocations = [
  { participant: participantA, asset: "usdc", amount: "1000000" },
  { participant: participantB, asset: "usdc", amount: "0" } 
]; // No change - all funds to participant A

// OR
const allocations = [
  { participant: participantA, asset: "usdc", amount: "0" },
  { participant: participantB, asset: "usdc", amount: "1000000" }
]; // All funds to participant B

// OR 
const allocations = [
  { participant: participantA, asset: "usdc", amount: "700000" },
  { participant: participantB, asset: "usdc", amount: "300000" }
]; // Split 70/30
```

## Understanding the Close Session Response

When you close an application session, the ClearNode responds with information about the closed session:

```javascript
// Example response
{
  "res": [
    3,                  // Request ID
    "close_app_session",  // Method name
    [
      {
        "app_session_id": "0x0ac588b2924edbbbe34bb4c51d089771bd7bd7018136c8c4317624112a8c9f79", // Session ID
        "status": "closed"
      }
    ],
    1631234567890      // Timestamp
  ],
  "sig": ["0xSignature"]
}
```

## Response Components

When closing an application session, the ClearNode responds with:

| Component | Description | Example |
|-----------|-------------|---------|
| **app_session_id** | Identifier of the application session | `"0x0ac588b2924edbbbe34bb4c51d089771bd7bd7018136c8c4317624112a8c9f79"` |
| **status** | Final state of the application session | `"closed"` |

## Common Scenarios for Closing Sessions

Here are some common scenarios where you would close an application session:

| Scenario | Description | Typical Allocation Pattern |
|----------|-------------|---------------------------|
| **Payment Completed** | User completes payment for a service | All funds to the service provider |
| **Game Completed** | End of a game with a winner | Winner gets the pot |
| **Partial Service** | Service partially delivered | Split based on completion percentage |
| **Cancellation** | Service cancelled before completion | Funds returned to original funder |
| **Dispute Resolution** | Resolution after a dispute | Split according to dispute resolution |


## Best Practices

When closing application sessions, follow these best practices:

1. **Verify all transactions are complete** before closing
2. **Include appropriate timeouts** to prevent hanging operations
3. **Clean up event listeners** to prevent memory leaks
4. **Implement retry logic** for failure recovery
5. **Store transaction records** for audit purposes
6. **Validate final allocations** match expected state

## Common Errors and Troubleshooting

When closing application sessions, you might encounter these issues:

| Error Type | Description | Solution |
|------------|-------------|----------|
| **Authentication errors** | WebSocket connection loses authentication | Re-authenticate before closing the session |
| **Session not found** | The app_session_id is invalid or the session was already closed | Verify the app_session_id is correct and the session is still active |
| **Allocation mismatch** | The total in final allocations doesn't match initial funding | Ensure allocations sum to the correct total amount |
| **Connection issues** | WebSocket disconnects during a close request | Implement reconnection logic with exponential backoff |
| **Timeout** | The ClearNode does not respond in a timely manner | Set appropriate timeouts and implement retry logic |

## Next Steps

After closing an application session, you can:

1. [Check your channel balances](balances) to verify the finalized allocations
2. [Create a new application session](application_session) if you need to continue with different parameters
3. [Close the channel](close_channel) if you're done with all interactions

For more advanced scenarios, see our detailed documentation on state channel lifecycle management.

---

---
sidebar_position: 9
title: Resize Channel
description: Adjust the funds locked in a channel to accommodate changing transaction requirements.
keywords: [erc7824, nitrolite, resize channel, funding, state channels]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Resize Channel

Resizing a channel allows you to adjust the funds allocated to it without closing and reopening the channel. This guide explains how to safely increase or decrease channel capacity.

## Why Resize a Channel?

You might need to resize a channel for several reasons:

- **Add more funds** when the channel is running low
- **Reduce allocated funds** when they're no longer needed
- **Adjust allocations** between participants
- **Work with broker/ClearNode** to ensure proper channel operation
- **Prepare for channel closure** by ensuring sufficient funds

## Channel Resize Methods

Nitrolite supports three primary methods for resizing a channel:

1. **Fund Addition**: Adding more funds to the channel
2. **Fund Removal**: Taking some funds out (partial withdrawal)
3. **Broker-Assisted Resize**: Working with a ClearNode to resize the channel when the broker needs to adjust its funds for closing

## Performing a Channel Resize

To resize a channel, you'll use the `createResizeChannelMessage` helper from NitroliteRPC and the `resizeChannel` method of your client. The `createResizeChannelMessage` function accepts a message signing function and an array of resize parameters. Here's how to implement it in different frameworks:

<Tabs>
  <TabItem value="react" label="React">

```javascript
import { useCallback } from 'react';
import { createResizeChannelMessage } from '@erc7824/nitrolite';

// Hook for handling channel resizing
export function useResize() {
  // Function to submit resize request to the NitroliteClient
  const handleResizeChannel = useCallback(async (resizeState, originalState) => {
    try {
      // Call client's resizeChannel with new state and proof of original state
      await NitroliteStore.state.client.resizeChannel({
        resizeState: resizeState,
        proofStates: [originalState],
      });
      return true;
    } catch (error) {
      console.error('Error resizing channel:', error);
      throw error;
    }
  }, []);

  return { handleResizeChannel };
}

// Hook implementing the resize flow
function useChannelResize() {
  const { handleResizeChannel } = useResize();
  
  const resizeChannel = useCallback(async () => {
    // Prerequisites check
    if (!isConnected || !walletAddress) {
      console.error('WebSocket not connected or wallet not connected');
      return;
    }
    
    setLoading(true);
    
    try {
      // 1. Retrieve channel data
      const channelId = localStorage.getItem('nitrolite_channel_id');
      const stateJson = localStorage.getItem('nitrolite_channel_state');
      
      if (!channelId || !stateJson || !stateSigner) {
        throw new Error('Missing channel data or signer');
      }
      
      // 2. Parse the stored channel state (handling BigInt conversion)
      const originalState = JSON.parse(stateJson, (key, value) => {
        return typeof value === 'string' && /^\d+n$/.test(value)
          ? BigInt(value.slice(0, -1))
          : value;
      });
      
      // 3. Create resize parameters for a deposit operation
      // Note: You can only use either allocate_amount OR resize_amount (not both)
      const resizeParams = [{
        channel_id: channelId,
        funds_destination: walletAddress,
        resize_amount: 50      // Deposit 50 tokens to this channel
      }];
      
      // 4. Create and send resize message to ClearNode
      const resizeMessage = await createResizeChannelMessage(
        stateSigner.sign, 
        resizeParams
      );
      const response = await sendRequest(resizeMessage);
      
      // 5. Process broker response
      const brokerState = response[0];
      const resizeState = {
        channelId: brokerState.channel_id,
        stateData: brokerState.state_data,
        version: brokerState.version,
        intent: brokerState.intent,
        allocations: brokerState.allocations.map(alloc => ({
          destination: allocation.destination,
          token: allocation.token,
          amount: allocation.amount,
        })),
        serverSignature: brokerState.server_signature,
      };
      
      // 6. Submit resize to client
      await handleResizeChannel(resizeState, originalState);
      
      // 7. Update app state after successful resize
      await refreshChannelData();
      
    } catch (error) {
      console.error('Resize failed:', error);
    } finally {
      setLoading(false);
    }
  }, [isConnected, walletAddress, stateSigner]);
  
  return { resizeChannel };
}
```

  </TabItem>
  <TabItem value="nodejs" label="Node.js">

```javascript
import { createResizeChannelMessage } from '@erc7824/nitrolite';
import { ethers } from 'ethers';

/**
 * Resize a channel with ClearNode assistance
 * @param {string} channelId - The channel ID
 * @param {WebSocket} ws - WebSocket connection to the ClearNode
 * @param {object} wallet - Ethers wallet for signing
 * @param {object} channelState - Current channel state
 * @returns {Promise<object>} Result with success status and channel ID
 */
async function resizeChannel(channelId, ws, wallet, channelState, client) {
  if (!channelId) throw new Error('Channel ID is required');
  
  try {
    // 1. Create message signer function
    const messageSigner = async (payload) => {
      const message = JSON.stringify(payload);
      const digestHex = ethers.id(message);
      const messageBytes = ethers.getBytes(digestHex);
      const { serialized: signature } = wallet.signingKey.sign(messageBytes);
      return signature;
    };
    
    // 2. Create resize parameters for a deposit operation
    // Note: You can only use either allocate_amount OR resize_amount (not both)
    const resizeParams = [{
      channel_id: channelId,
      funds_destination: wallet.address,
      resize_amount: 50      // Deposit 50 tokens to this channel
    }];
    
    // 3. Create and send the resize message
    const resizeMessage = await createResizeChannelMessage(messageSigner, resizeParams);
    
    // 4. Process the response
    return await handleWebSocketResponse(ws, resizeMessage, channelState, client);
  } catch (error) {
    console.error(`Error resizing channel ${channelId}:`, error);
    throw error;
  }
}

/**
 * Handle WebSocket communication for channel resize
 */
function handleWebSocketResponse(ws, resizeMessage, channelState, client) {
  return new Promise((resolve, reject) => {
    const handleResizeResponse = (data) => {
      try {
        const rawData = typeof data === 'string' ? data : data.toString();
        const message = JSON.parse(rawData);
        
        // Success response
        if (message.res && message.res[1] === 'resize_channel') {
          ws.removeListener('message', handleResizeResponse);
          
          // Extract and format broker state
          const brokerState = message.res[2][0];
          const resizeState = {
            channelId: brokerState.channel_id,
            stateData: brokerState.state_data,
            version: brokerState.version,
            intent: brokerState.intent,
            allocations: brokerState.allocations,
            serverSignature: brokerState.server_signature,
          };
          
          // Submit to client
          client.resizeChannel({
            resizeState: resizeState,
            proofStates: [channelState],
          })
          .then(() => {
            resolve({
              success: true,
              channelId: brokerState.channel_id
            });
          })
          .catch(error => {
            reject(new Error(`Resize completion failed: ${error.message}`));
          });
        }
        
        // Error response
        if (message.err) {
          ws.removeListener('message', handleResizeResponse);
          reject(new Error(`Error ${message.err[1]}: ${message.err[2]}`));
        }
      } catch (error) {
        console.error('Error handling resize response:', error);
      }
    };
    
    // Set up message handling
    ws.on('message', handleResizeResponse);
    
    // Set timeout (15 seconds)
    setTimeout(() => {
      ws.removeListener('message', handleResizeResponse);
      reject(new Error('Resize timeout after 15 seconds'));
    }, 15000);
    
    // Send the message
    ws.send(resizeMessage);
  });
}

// Usage example
const channelId = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
const channelState = loadChannelState(channelId);

resizeChannel(channelId, ws, wallet, channelState, client)
  .then(result => console.log(`Channel ${result.channelId} resized successfully`))
  .catch(error => console.error('Resize failed:', error));
```

  </TabItem>
  <TabItem value="angular" label="Angular">

```typescript
// channel-resize.service.ts
import { Injectable } from '@angular/core';
import { createResizeChannelMessage } from '@erc7824/nitrolite';
import { ethers } from 'ethers';
import { BehaviorSubject, Observable, from } from 'rxjs';
import { tap, catchError, switchMap } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class ChannelResizeService {
  private webSocket: WebSocket | null = null;
  private channelIdSubject = new BehaviorSubject<string | null>(null);
  
  public channelId$ = this.channelIdSubject.asObservable();
  
  constructor() {
    // Load channel ID from storage
    const storedChannelId = localStorage.getItem('nitrolite_channel_id');
    if (storedChannelId) this.channelIdSubject.next(storedChannelId);
  }
  
  public setWebSocket(ws: WebSocket): void {
    this.webSocket = ws;
  }
  
  /**
   * Main method to resize a channel
   */
  public resizeChannel(signer: any, client: any, channelId: string): Observable<any> {
    // 1. Validate prerequisites
    if (!this.webSocket) throw new Error('WebSocket not connected');
    if (!channelId) throw new Error('Channel ID required');
    
    // 2. Load channel state
    const stateJson = localStorage.getItem('nitrolite_channel_state');
    if (!stateJson) throw new Error('No channel state found');
    const channelState = JSON.parse(stateJson);
    
    // 3. Execute resize flow using RxJS pipes
    return from(this.createResizeMessage(signer, channelId)).pipe(
      switchMap(message => this.sendResizeRequest(message)),
      switchMap(brokerState => this.processResize(client, brokerState, channelState)),
      tap(() => console.log('Channel resized successfully')),
      catchError(error => {
        console.error('Resize failed:', error);
        throw error;
      })
    );
  }
  
  /**
   * Create the signed resize message
   */
  private async createResizeMessage(signer: any, channelId: string): Promise<string> {
    try {
      // Get user address and create message signer function
      const address = await signer.getAddress();
      const messageSigner = async (payload: any) => {
        const message = JSON.stringify(payload);
        const digestHex = ethers.id(message);
        const messageBytes = ethers.getBytes(digestHex);
        return await signer.signMessage(messageBytes);
      };
      
      // Create resize parameters for a deposit operation
      // Note: You can only use either allocate_amount OR resize_amount (not both)
      const resizeParams = [{
        channel_id: channelId,
        funds_destination: address,
        resize_amount: 50      // Deposit 50 tokens to this channel
      }];
      
      return await createResizeChannelMessage(messageSigner, resizeParams);
    } catch (error) {
      console.error('Error creating resize message:', error);
      throw error;
    }
  }
  
  /**
   * Send resize request to ClearNode via WebSocket
   */
  private sendResizeRequest(resizeMessage: string): Promise<any> {
    return new Promise((resolve, reject) => {
      if (!this.webSocket) {
        reject(new Error('WebSocket not connected'));
        return;
      }
      
      const handleMessage = (event: MessageEvent) => {
        try {
          const message = JSON.parse(event.data);
          // Success response
          if (message.res && message.res[1] === 'resize_channel') {
            this.webSocket?.removeEventListener('message', handleMessage);
            resolve(message.res[2][0]); // Return broker state
          }
          
          // Error response
          if (message.err) {
            this.webSocket?.removeEventListener('message', handleMessage);
            reject(new Error(`Error: ${message.err[1]} - ${message.err[2]}`));
          }
        } catch (error) {
          console.error('Error parsing message:', error);
        }
      };
      
      // Set up message handling with timeout
      this.webSocket.addEventListener('message', handleMessage);
      setTimeout(() => {
        this.webSocket?.removeEventListener('message', handleMessage);
        reject(new Error('Resize timeout after 15 seconds'));
      }, 15000);
      
      // Send the message
      this.webSocket.send(resizeMessage);
    });
  }
  
  /**
   * Process broker response and submit to client
   */
  private async processResize(client: any, brokerState: any, channelState: any): Promise<any> {
    // Format resize state data from broker response
    const resizeStateData = {
      channelId: brokerState.channel_id,
      stateData: brokerState.state_data,
      version: brokerState.version,
      intent: brokerState.intent,
      allocations: brokerState.allocations.map((alloc: any) => ({
        destination: allocation.destination,
        token: allocation.token,
        amount: allocation.amount,
      })),
      serverSignature: brokerState.server_signature,
    };
    
    // Submit to client
    return await client.resizeChannel({
      resizeState: resizeStateData,
      proofStates: [channelState],
    });
  }
}

// channel-resize.component.ts
import { Component, OnInit } from '@angular/core';
import { ChannelResizeService } from './channel-resize.service';

@Component({
  selector: 'app-channel-resize',
  template: `
    <div class="channel-container">
      <h3>Resize Channel</h3>
      <div *ngIf="channelId" class="channel-info">
        <p>Channel ID: {{ channelId }}</p>
        <button (click)="resizeChannel()" [disabled]="isResizing">
          {{ isResizing ? 'Resizing...' : 'Resize Channel' }}
        </button>
      </div>
      
      <div *ngIf="!channelId" class="info-message">No active channel found.</div>
      <div *ngIf="error" class="error-message">{{ error }}</div>
      <div *ngIf="success" class="success-message">Channel resized successfully!</div>
    </div>
  `,
  styles: [`
    .channel-container { margin: 20px; padding: 15px; border: 1px solid #eee; border-radius: 5px; }
    .channel-info { margin-bottom: 15px; }
    .error-message { color: red; margin-top: 10px; }
    .success-message { color: green; margin-top: 10px; }
    .info-message { color: blue; margin-top: 10px; }
  `]
})
export class ChannelResizeComponent implements OnInit {
  channelId: string | null = null;
  isResizing = false;
  error: string | null = null;
  success = false;
  
  constructor(
    private resizeService: ChannelResizeService,
    private nitroliteClient: any
  ) {}
  
  ngOnInit(): void {
    // Subscribe to channel ID changes
    this.resizeService.channelId$.subscribe(id => {
      this.channelId = id;
      this.success = false;
    });
    
    // Initialize WebSocket
    this.initWebSocket();
  }
  
  private initWebSocket(): void {
    const ws = new WebSocket('wss://your-clearnode-endpoint');
    ws.onopen = () => this.resizeService.setWebSocket(ws);
  }
  
  resizeChannel(): void {
    if (!this.channelId) {
      this.error = 'No active channel';
      return;
    }
    
    this.isResizing = true;
    this.error = null;
    this.success = false;
    
    // Get signer from wallet provider
    const provider = window.ethereum && new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider?.getSigner();
    
    if (!signer) {
      this.error = 'No wallet connected';
      this.isResizing = false;
      return;
    }
    
    // Execute resize
    this.resizeService.resizeChannel(signer, this.nitroliteClient, this.channelId)
      .subscribe({
        next: () => {
          this.success = true;
          this.isResizing = false;
        },
        error: (err) => {
          this.error = `Resize failed: ${err.message}`;
          this.isResizing = false;
        }
      });
  }
}
```

  </TabItem>
  <TabItem value="vue" label="Vue.js">

```javascript
<!-- ChannelResize.vue -->
<template>
  <div class="channel-resize">
    <h3>Resize Channel</h3>
    
    <div v-if="channelId" class="active-channel">
      <p>Channel ID: {{ channelId }}</p>
      <button @click="resizeChannel" :disabled="isResizing || !isConnected">
        {{ isResizing ? 'Resizing Channel...' : 'Resize Channel' }}
      </button>
    </div>
    
    <div v-else class="no-channel">No active channel found.</div>
    <div v-if="error" class="error-message">{{ error }}</div>
    <div v-if="success" class="success-message">Channel resized successfully!</div>
    <div v-if="!isConnected" class="warning-message">WebSocket not connected</div>
  </div>
</template>

<script>
import { defineComponent, ref, onMounted, onUnmounted } from 'vue';
import { createResizeChannelMessage } from '@erc7824/nitrolite';
import { ethers } from 'ethers';

export default defineComponent({
  name: 'ChannelResize',
  
  setup() {
    // State references
    const channelId = ref(localStorage.getItem('nitrolite_channel_id') || null);
    const channelState = ref(null);
    const isResizing = ref(false);
    const error = ref(null);
    const success = ref(false);
    const isConnected = ref(false);
    let webSocket = null;
    
    // Lifecycle hooks
    onMounted(() => {
      loadChannelState();
      initWebSocket();
    });
    
    onUnmounted(() => {
      if (webSocket) webSocket.close();
    });
    
    // Load channel state from storage
    const loadChannelState = () => {
      const storedState = localStorage.getItem('nitrolite_channel_state');
      if (!storedState) return;
      
      try {
        // Parse JSON with BigInt support
        channelState.value = JSON.parse(storedState, (key, value) => {
          return typeof value === 'string' && /^\d+n$/.test(value)
            ? BigInt(value.slice(0, -1))
            : value;
        });
      } catch (err) {
        console.error('Error parsing channel state:', err);
      }
    };
    
    // Initialize WebSocket connection
    const initWebSocket = () => {
      webSocket = new WebSocket('wss://your-clearnode-endpoint');
      webSocket.onopen = () => isConnected.value = true;
      webSocket.onclose = () => isConnected.value = false;
      webSocket.onerror = () => {
        isConnected.value = false;
        error.value = 'WebSocket connection error';
      };
    };
    
    // Main resize function
    const resizeChannel = async () => {
      // 1. Validate prerequisites
      if (!isConnected.value || !webSocket) {
        error.value = 'WebSocket not connected';
        return;
      }
      
      if (!channelId.value || !channelState.value) {
        error.value = 'Missing channel data';
        return;
      }
      
      try {
        // 2. Set up UI state
        isResizing.value = true;
        error.value = null;
        success.value = false;
        
        // 3. Get wallet signer
        if (!window.ethereum) throw new Error('No Ethereum provider');
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();
        const address = await signer.getAddress();
        
        // 4. Create message signer and resize parameters
        const messageSigner = async (payload) => {
          const message = JSON.stringify(payload);
          const digestHex = ethers.id(message);
          return await signer.signMessage(ethers.getBytes(digestHex));
        };
        
        // Create resize parameters for a deposit operation
        // Note: You can only use either allocate_amount OR resize_amount (not both)
        const resizeParams = [{
          channel_id: channelId.value,
          funds_destination: address,
          resize_amount: 50      // Deposit 50 tokens to this channel
        }];
        
        // 5. Create and send resize message
        const resizeMessage = await createResizeChannelMessage(messageSigner, resizeParams);
        const brokerState = await sendWebSocketRequest(resizeMessage);
        
        // 6. Format and submit resize state
        const resizeStateData = {
          channelId: brokerState.channel_id,
          stateData: brokerState.state_data,
          version: brokerState.version,
          intent: brokerState.intent,
          allocations: brokerState.allocations.map(alloc => ({
            destination: allocation.destination,
            token: allocation.token,
            amount: allocation.amount,
          })),
          serverSignature: brokerState.server_signature,
        };
        
        await window.nitroliteClient.resizeChannel({
          resizeState: resizeStateData,
          proofStates: [channelState.value],
        });
        
        // 7. Update state after success
        success.value = true;
        await refreshChannelState();
        
      } catch (err) {
        error.value = err.message || 'Resize failed';
        console.error('Resize error:', err);
      } finally {
        isResizing.value = false;
      }
    };
    
    // Send WebSocket request and handle response
    const sendWebSocketRequest = (payload) => {
      return new Promise((resolve, reject) => {
        const handleMessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            
            // Success response
            if (message.res && message.res[1] === 'resize_channel') {
              webSocket.removeEventListener('message', handleMessage);
              resolve(message.res[2][0]); // Broker state
            }
            
            // Error response
            if (message.err) {
              webSocket.removeEventListener('message', handleMessage);
              reject(new Error(`${message.err[1]}: ${message.err[2]}`));
            }
          } catch (error) {
            console.error('Error parsing message:', error);
          }
        };
        
        // Setup listener with timeout
        webSocket.addEventListener('message', handleMessage);
        setTimeout(() => {
          webSocket.removeEventListener('message', handleMessage);
          reject(new Error('Resize timeout'));
        }, 15000);
        
        webSocket.send(payload);
      });
    };
    
    // Update channel state after resize
    const refreshChannelState = async () => {
      try {
        // Get updated state from client
        const newState = await window.nitroliteClient.getChannelState(channelId.value);
        
        // Store with BigInt serialization
        localStorage.setItem('nitrolite_channel_state', 
          JSON.stringify(newState, (key, value) => {
            return typeof value === 'bigint' ? value.toString() + 'n' : value;
          })
        );
        
        channelState.value = newState;
      } catch (err) {
        console.error('Error refreshing state:', err);
      }
    };
    
    return { channelId, isResizing, error, success, isConnected, resizeChannel };
  }
});
</script>

<style scoped>
.channel-resize {
  padding: 20px;
  border: 1px solid #eee;
  border-radius: 8px;
  margin-bottom: 20px;
}
.active-channel {
  margin-bottom: 15px;
  padding: 10px;
  background-color: #f5f5f5;
  border-radius: 4px;
}
.error-message { color: #d32f2f; margin-top: 10px; }
.success-message { color: #388e3c; margin-top: 10px; }
.warning-message { color: #f57c00; margin-top: 10px; }
button {
  padding: 8px 16px;
  background-color: #1976d2;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
button:disabled { background-color: #bbdefb; cursor: not-allowed; }
</style>
```

  </TabItem>
</Tabs>

## Understanding Broker-Assisted Resize

When resizing a channel with a ClearNode or broker, the process involves:

1. **Creating a resize request** using `createResizeChannelMessage` with appropriate parameters
2. **Sending the resize request** to the ClearNode via WebSocket
3. **Receiving broker state** from the ClearNode with new state information
4. **Processing the resize** by calling the client's `resizeChannel` method with both:
   - The new broker state (resizeState)
   - The original channel state (proofStates)

This flow is particularly important when:
- The broker needs to adjust its funds for closing a channel
- Channel capacity needs to be adjusted while keeping operations active
- A recovery or correction is needed for channel state

## The Resize Message Structure

The `createResizeChannelMessage` function takes two parameters:

1. `messageSigner`: A function that takes a payload and returns a signature
2. `resizeParams`: An array of resize operation objects

Each resize operation object in the array includes:

| Parameter | Description | Example |
|-----------|-------------|---------|
| `channel_id` | Identifier for the channel to resize | `"0x1234567890abcdef..."` |
| `funds_destination` | Address where funds would go | `"0xUserAddress..."` |
| `allocate_amount` | Amount of tokens to allocate to this specific channel from unified balance | `80` (allocate 80 tokens from unified balance) |
| `resize_amount` | Amount to deposit (positive) or withdraw (negative) from the channel | `75` (deposit 75 tokens) or `-100` (withdraw 100 tokens) |

## Broker Response Structure

The ClearNode's response contains a new state that includes:

| Component | Description | Example |
|-----------|-------------|---------|
| `channel_id` | Identifier for the channel | `"0x1234567890abcdef..."` |
| `state_data` | Encoded state data | `"0x000000..."` |
| `intent` | Purpose code for this state | `2` |
| `version` | State version number | `1` |
| `allocations` | Array of token allocations | `[{destination, token, amount}]` |
| `state_hash` | Hash of the state | `"0x61cec3..."` |
| `server_signature` | Broker's signature | `{v, r, s}` values |

## Understanding Allocation and Resize Amounts

When working with Nitrolite channels across different networks, it's important to understand how to use `allocate_amount` and `resize_amount`:

- **`allocate_amount`**: Controls how much of your unified token balance is allocated to a specific channel on a specific network.
- **`resize_amount`**: Controls how much you want to deposit to or withdraw from a specific channel.

**IMPORTANT**: In a single resize operation, you can only use either `allocate_amount` OR `resize_amount`, not both at the same time. Only include the parameter you're using.

### Allocation and Resize Examples

**Example 1: Depositing to a Channel**

Initial state:
- User has channels on Polygon (20 USDC) and Celo (5 USDC)
- Total unified balance: 25 USDC

To deposit 75 USDC to Celo channel:
```javascript
const resizeParams = [{
  channel_id: "0xCeloChannelId...",
  funds_destination: userAddress,
  resize_amount: 75        // Deposit 75 USDC
}];
```

Result:
- Polygon channel: 20 USDC
- Celo channel: 80 USDC
- Total unified balance: 100 USDC

**Example 2: Withdrawing All Funds to a Specific Network**

Initial state (after Example 1):
- Polygon channel: 20 USDC
- Celo channel: 80 USDC
- Total unified balance: 100 USDC

To withdraw all 100 USDC to Polygon:
```javascript
// Step 1: First allocate funds from Celo to Polygon
const allocateParams = [{
  channel_id: "0xPolygonChannelId...",
  funds_destination: userAddress,
  allocate_amount: 80     // Allocate 80 USDC from Celo to Polygon
}];

// Step 2: Then withdraw from Polygon
const withdrawParams = [{
  channel_id: "0xPolygonChannelId...",
  funds_destination: userAddress,
  resize_amount: -100      // Withdraw 100 USDC
}];

// For deallocating from Celo when needed:
const deallocateParams = [{
  channel_id: "0xCeloChannelId...",
  funds_destination: userAddress,
  allocate_amount: -80    // Deallocate all funds from Celo
}];
```

Result:
- All 100 USDC withdrawn to user's wallet on Polygon
- Channels may remain open with zero balance

## Common Use Cases for Channel Resize

| Scenario | Description | Implementation Details |
|----------|-------------|------------------------|
| **Pre-closure Preparation** | Ensuring broker has sufficient funds to close the channel | Use resize before closure to adjust broker funds |
| **Adding Capacity** | Increasing channel capacity for continued operations | Add funds to the channel with appropriate allocations |
| **Balance Adjustment** | Adjusting balances between participants | Resize with new allocation values |
| **Cross-Network Transfers** | Moving funds between channels on different networks | Use allocation to move funds between networks |
| **Withdrawals** | Withdrawing funds from the system | Allocate funds to target network, then use negative resize_amount |
| **Recovery** | Recovering from an inconsistent state | Work with broker to establish correct state |

## Best Practices

When resizing channels, follow these best practices:

1. **Always store channel states** so they're available when needed for resize operations
2. **Validate broker responses** by checking signatures and parameters
3. **Implement proper error handling** for timeout and connection issues
4. **Clean up event listeners** to prevent memory leaks
5. **Provide clear user feedback** during the resize process
6. **Use allocate_amount OR resize_amount (not both)** in a single operation:
   - To deposit: Use only `resize_amount: [positive amount]`
   - To withdraw: First allocate funds to the target channel (in a separate operation), then use negative resize_amount
   - To transfer between networks: Use only allocation `allocate_amount: [amount]`
7. **When withdrawing all funds**, consider deallocating from other channels

## Common Allocation and Resize Scenarios

Remember: You can only use either `allocate_amount` OR `resize_amount` in a single operation, not both.

| Action | Parameter to Use | Value | Example |
|--------|-----------------|-------|---------|
| **Simple deposit** | resize_amount | Positive amount | `resize_amount: 50` |
| **Simple withdrawal** | resize_amount | Negative amount | `resize_amount: -30` |
| **Cross-network allocation** | allocate_amount | Positive amount | `allocate_amount: 75` |
| **Deallocate** | allocate_amount | Negative amount | `allocate_amount: -40` |
| **Withdraw from multiple channels** | Two separate operations | Operation 1: allocate_amount (positive)<br/>Operation 2: resize_amount (negative) | Step 1: `allocate_amount: 80`<br/>Step 2: `resize_amount: -100` |

## Common Errors and Troubleshooting

| Error Type | Description | Solution |
|------------|-------------|----------|
| **Missing state** | No channel state is available | Ensure channel state is saved after creation and transactions |
| **Broker timeout** | ClearNode does not respond in time | Implement retry logic with exponential backoff |
| **Invalid signature** | Broker signature cannot be verified | Ensure proper cryptographic setup and validation |
| **State mismatch** | Channel state doesn't match broker expectations | Synchronize state with the broker before resize |

## Next Steps

After resizing your channel, you can:

1. [Continue with existing application sessions](application_session)
2. [Check your channel balances](balances) to verify the new allocation
3. [Close the channel](close_channel) if resize was in preparation for closing

---

---
sidebar_position: 11
title: Close Channel
description: Properly shut down a state channel and settle the final state on-chain.
keywords: [erc7824, nitrolite, close channel, finalize, settlement, state channels]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Close Channel

Properly closing a state channel is crucial to ensure that all participants receive their rightful funds according to the latest agreed state. This guide explains how to safely close a channel through mutual agreement.

## Understanding Channel Closure

Closing a channel properly involves:

- Agreement on the final state by all participants
- Submitting the agreed state to the blockchain
- Transitioning from off-chain to on-chain settlement
- Preparing for fund withdrawal

## Prerequisites for Closing a Channel

Before closing a channel, ensure:

1. All application sessions within the channel are properly closed
2. All participants are ready to sign the final state
3. You have the latest state with all participants' signatures
4. Your client is connected and has access to your wallet

## Closing a Channel

To close a channel, you'll use the `createCloseChannelMessage` helper from NitroliteRPC and the `closeChannel` method of your client. Here's how to implement it in different frameworks:

<Tabs>
  <TabItem value="react" label="React">

```javascript
import { useCallback } from 'react';
import { createCloseChannelMessage } from '@erc7824/nitrolite';

// Hook for handling channel closing
export function useChannelClose() {
  // Clear channel data from local storage
  const clearStoredChannel = useCallback(() => {
    try {
      localStorage.removeItem('nitrolite_channel');
      localStorage.removeItem('nitrolite_channel_state');
      localStorage.removeItem('nitrolite_channel_id');
      console.log('Cleared channel data from storage');
    } catch (error) {
      console.error('Error clearing channel data:', error);
    }
  }, []);

  // Process the final state from ClearNode
  const handleCloseChannel = useCallback(async (finalState) => {
    try {
      // 1. Extract broker state
      const brokerState = finalState[0];

      // 2. Format final state data
      const finalStateData = {
        channelId: brokerState.channel_id,
        stateData: brokerState.state_data,
        version: brokerState.version,
        allocations: brokerState.allocations.map(alloc => ({
          destination: alloc.destination,
          token: alloc.token,
          amount: alloc.amount,
        })),
        serverSignature: brokerState.server_signature,
      };

      // 3. Submit close request to client
      await NitroliteStore.state.client.closeChannel({
        stateData: brokerState.state_data,
        finalState: finalStateData,
      });

      // 4. Clean up after successful closing
      clearStoredChannel();
      WalletStore.closeChannel();

      return true;
    } catch (error) {
      console.error('Error closing channel:', error);
      WalletStore.setChannelOpen(false);
      throw error;
    }
  }, [clearStoredChannel]);

  // Main function to close a channel
  const closeChannel = useCallback(async () => {
    // 1. Check prerequisites
    if (!isConnected || !walletAddress) {
      console.error('WebSocket not connected or wallet not connected');
      return;
    }

    setLoading(true);

    try {
      // 2. Get channel ID and verify signer
      const channelId = localStorage.getItem('nitrolite_channel_id');
      if (!channelId || !stateSigner) {
        throw new Error('Missing channel data or signer');
      }

      // 3. Create and send close message
      const closeMessage = await createCloseChannelMessage(
        stateSigner.sign,
        channelId,
        walletAddress  // funds destination
      );
      const response = await sendRequest(closeMessage);

      // 4. Process close response
      await handleCloseChannel(response);

      // 5. Update application state
      await refreshData();

      console.log('Channel closed successfully');
    } catch (error) {
      console.error('Error closing channel:', error);
    } finally {
      setLoading(false);
    }
  }, [isConnected, walletAddress, stateSigner, sendRequest, handleCloseChannel, refreshData]);

  return { closeChannel, handleCloseChannel, clearStoredChannel };
}
```

  </TabItem>
  <TabItem value="nodejs" label="Node.js">

```javascript
import { createCloseChannelMessage } from '@erc7824/nitrolite';
import { ethers } from 'ethers';

/**
 * Close a channel with ClearNode assistance
 * @param {string} channelId - The channel ID
 * @param {WebSocket} ws - WebSocket connection to the ClearNode
 * @param {object} wallet - Ethers wallet for signing
 * @param {object} client - Nitrolite client
 * @returns {Promise<object>} Result with success status
 */
async function closeChannel(channelId, ws, wallet, client) {
  if (!channelId) throw new Error('Channel ID is required');
  
  try {
    console.log(`Closing channel ${channelId}`);
    
    // 1. Create message signer function
    const messageSigner = async (payload) => {
      const message = JSON.stringify(payload);
      const digestHex = ethers.id(message);
      const messageBytes = ethers.getBytes(digestHex);
      const { serialized: signature } = wallet.signingKey.sign(messageBytes);
      return signature;
    };
    
    // 2. Create and send close message
    const closeMessage = await createCloseChannelMessage(
      messageSigner,
      channelId,
      wallet.address // funds destination
    );
    
    // 3. Process response
    return await handleCloseResponse(ws, closeMessage, client);
  } catch (error) {
    console.error(`Error closing channel ${channelId}:`, error);
    throw error;
  }
}

/**
 * Handle WebSocket communication for channel closing
 */
function handleCloseResponse(ws, closeMessage, client) {
  return new Promise((resolve, reject) => {
    const handleResponse = (data) => {
      try {
        const rawData = typeof data === 'string' ? data : data.toString();
        const message = JSON.parse(rawData);
        
        // Success response
        if (message.res && message.res[1] === 'close_channel') {
          ws.removeListener('message', handleResponse);
          
          // Extract broker state
          const brokerState = message.res[2][0];
          
          // Format final state
          const finalState = {
            channelId: brokerState.channel_id,
            stateData: brokerState.state_data,
            version: brokerState.version,
            allocations: brokerState.allocations,
            serverSignature: brokerState.server_signature,
          };
          
          // Submit to client
          client.closeChannel({
            stateData: brokerState.state_data,
            finalState: finalState,
          })
          .then(() => {
            resolve({
              success: true,
              channelId: brokerState.channel_id
            });
          })
          .catch(error => {
            reject(new Error(`Close finalization failed: ${error.message}`));
          });
        }
        
        // Error response
        if (message.err) {
          ws.removeListener('message', handleResponse);
          reject(new Error(`Error ${message.err[1]}: ${message.err[2]}`));
        }
      } catch (error) {
        console.error('Error handling close response:', error);
      }
    };
    
    // Set up message handling
    ws.on('message', handleResponse);
    
    // Set timeout (15 seconds)
    setTimeout(() => {
      ws.removeListener('message', handleResponse);
      reject(new Error('Close timeout after 15 seconds'));
    }, 15000);
    
    // Send the message
    ws.send(closeMessage);
  });
}

// Usage example
const channelId = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';

closeChannel(channelId, ws, wallet, client)
  .then(result => console.log(`Channel ${result.channelId} closed successfully`))
  .catch(error => console.error('Close failed:', error));
```

  </TabItem>
  <TabItem value="angular" label="Angular">

```typescript
// channel-close.service.ts
import { Injectable } from '@angular/core';
import { createCloseChannelMessage } from '@erc7824/nitrolite';
import { ethers } from 'ethers';
import { BehaviorSubject, Observable, from } from 'rxjs';
import { tap, catchError, switchMap, finalize } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class ChannelCloseService {
  private webSocket: WebSocket | null = null;
  private channelIdSubject = new BehaviorSubject<string | null>(null);
  
  public channelId$ = this.channelIdSubject.asObservable();
  
  constructor() {
    // Load channel ID from storage
    const storedChannelId = localStorage.getItem('nitrolite_channel_id');
    if (storedChannelId) this.channelIdSubject.next(storedChannelId);
  }
  
  public setWebSocket(ws: WebSocket): void {
    this.webSocket = ws;
  }
  
  /**
   * Clear channel data from storage
   */
  public clearChannelData(): void {
    localStorage.removeItem('nitrolite_channel');
    localStorage.removeItem('nitrolite_channel_state');
    localStorage.removeItem('nitrolite_channel_id');
    this.channelIdSubject.next(null);
  }
  
  /**
   * Main method to close a channel
   */
  public closeChannel(signer: any, client: any, channelId: string): Observable<any> {
    // 1. Validate prerequisites
    if (!this.webSocket) throw new Error('WebSocket not connected');
    if (!channelId) throw new Error('Channel ID required');
    
    // 2. Execute close flow using RxJS pipes
    return from(this.createCloseMessage(signer, channelId)).pipe(
      switchMap(message => this.sendCloseRequest(message)),
      switchMap(brokerState => this.processClose(client, brokerState)),
      tap(() => {
        console.log('Channel closed successfully');
        this.clearChannelData();
      }),
      catchError(error => {
        console.error('Close failed:', error);
        throw error;
      })
    );
  }
  
  /**
   * Create the signed close message
   */
  private async createCloseMessage(signer: any, channelId: string): Promise<string> {
    try {
      // Get user address and create message signer function
      const address = await signer.getAddress();
      const messageSigner = async (payload: any) => {
        const message = JSON.stringify(payload);
        const digestHex = ethers.id(message);
        const messageBytes = ethers.getBytes(digestHex);
        return await signer.signMessage(messageBytes);
      };
      
      // Create close message
      return await createCloseChannelMessage(messageSigner, channelId, address);
    } catch (error) {
      console.error('Error creating close message:', error);
      throw error;
    }
  }
  
  /**
   * Send close request to ClearNode via WebSocket
   */
  private sendCloseRequest(closeMessage: string): Promise<any> {
    return new Promise((resolve, reject) => {
      if (!this.webSocket) {
        reject(new Error('WebSocket not connected'));
        return;
      }
      
      const handleMessage = (event: MessageEvent) => {
        try {
          const message = JSON.parse(event.data);
          // Success response
          if (message.res && message.res[1] === 'close_channel') {
            this.webSocket?.removeEventListener('message', handleMessage);
            resolve(message.res[2][0]); // Return broker state
          }
          
          // Error response
          if (message.err) {
            this.webSocket?.removeEventListener('message', handleMessage);
            reject(new Error(`Error: ${message.err[1]} - ${message.err[2]}`));
          }
        } catch (error) {
          console.error('Error parsing message:', error);
        }
      };
      
      // Set up message handling with timeout
      this.webSocket.addEventListener('message', handleMessage);
      setTimeout(() => {
        this.webSocket?.removeEventListener('message', handleMessage);
        reject(new Error('Close timeout after 15 seconds'));
      }, 15000);
      
      // Send the message
      this.webSocket.send(closeMessage);
    });
  }
  
  /**
   * Process broker response and submit to client
   */
  private async processClose(client: any, brokerState: any): Promise<any> {
    // Format final state data from broker response
    const finalStateData = {
      channelId: brokerState.channel_id,
      stateData: brokerState.state_data,
      version: brokerState.version,
      allocations: brokerState.allocations.map((alloc: any) => ({
        destination: alloc.destination,
        token: alloc.token,
        amount: alloc.amount,
      })),
      serverSignature: brokerState.server_signature,
    };
    
    // Submit to client
    return await client.closeChannel({
      stateData: brokerState.state_data,
      finalState: finalStateData,
    });
  }
}

// channel-close.component.ts
import { Component, OnInit } from '@angular/core';
import { ChannelCloseService } from './channel-close.service';

@Component({
  selector: 'app-channel-close',
  template: `
    <div class="channel-container">
      <h3>Close Channel</h3>
      <div *ngIf="channelId" class="channel-info">
        <p>Channel ID: {{ channelId }}</p>
        <button (click)="closeChannel()" [disabled]="isClosing">
          {{ isClosing ? 'Closing...' : 'Close Channel' }}
        </button>
      </div>
      
      <div *ngIf="!channelId" class="info-message">No active channel found.</div>
      <div *ngIf="error" class="error-message">{{ error }}</div>
      <div *ngIf="success" class="success-message">Channel closed successfully!</div>
    </div>
  `,
  styles: [`
    .channel-container { margin: 20px; padding: 15px; border: 1px solid #eee; border-radius: 5px; }
    .channel-info { margin-bottom: 15px; }
    .error-message { color: red; margin-top: 10px; }
    .success-message { color: green; margin-top: 10px; }
    .info-message { color: blue; margin-top: 10px; }
  `]
})
export class ChannelCloseComponent implements OnInit {
  channelId: string | null = null;
  isClosing = false;
  error: string | null = null;
  success = false;
  
  constructor(
    private closeService: ChannelCloseService,
    private nitroliteClient: any
  ) {}
  
  ngOnInit(): void {
    // Subscribe to channel ID changes
    this.closeService.channelId$.subscribe(id => {
      this.channelId = id;
      this.success = false;
    });
    
    // Initialize WebSocket
    this.initWebSocket();
  }
  
  private initWebSocket(): void {
    const ws = new WebSocket('wss://your-clearnode-endpoint');
    ws.onopen = () => this.closeService.setWebSocket(ws);
  }
  
  closeChannel(): void {
    if (!this.channelId) {
      this.error = 'No active channel';
      return;
    }
    
    this.isClosing = true;
    this.error = null;
    this.success = false;
    
    // Get signer from wallet provider
    const provider = window.ethereum && new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider?.getSigner();
    
    if (!signer) {
      this.error = 'No wallet connected';
      this.isClosing = false;
      return;
    }
    
    // Execute close
    this.closeService.closeChannel(signer, this.nitroliteClient, this.channelId)
      .subscribe({
        next: () => {
          this.success = true;
          this.isClosing = false;
        },
        error: (err) => {
          this.error = `Close failed: ${err.message}`;
          this.isClosing = false;
        }
      });
  }
}
```

  </TabItem>
  <TabItem value="vue" label="Vue.js">

```javascript
<!-- ChannelClose.vue -->
<template>
  <div class="channel-close">
    <h3>Close Channel</h3>
    
    <div v-if="channelId" class="active-channel">
      <p>Channel ID: {{ channelId }}</p>
      <button @click="closeChannel" :disabled="isClosing || !isConnected">
        {{ isClosing ? 'Closing Channel...' : 'Close Channel' }}
      </button>
    </div>
    
    <div v-else class="no-channel">No active channel found.</div>
    <div v-if="error" class="error-message">{{ error }}</div>
    <div v-if="success" class="success-message">Channel closed successfully!</div>
    <div v-if="!isConnected" class="warning-message">WebSocket not connected</div>
  </div>
</template>

<script>
import { defineComponent, ref, onMounted, onUnmounted } from 'vue';
import { createCloseChannelMessage } from '@erc7824/nitrolite';
import { ethers } from 'ethers';

export default defineComponent({
  name: 'ChannelClose',
  
  setup() {
    // State references
    const channelId = ref(localStorage.getItem('nitrolite_channel_id') || null);
    const isClosing = ref(false);
    const error = ref(null);
    const success = ref(false);
    const isConnected = ref(false);
    let webSocket = null;
    
    // Lifecycle hooks
    onMounted(() => {
      initWebSocket();
    });
    
    onUnmounted(() => {
      if (webSocket) webSocket.close();
    });
    
    // Clear channel data from storage
    const clearChannelData = () => {
      localStorage.removeItem('nitrolite_channel');
      localStorage.removeItem('nitrolite_channel_state');
      localStorage.removeItem('nitrolite_channel_id');
      channelId.value = null;
    };
    
    // Initialize WebSocket connection
    const initWebSocket = () => {
      webSocket = new WebSocket('wss://your-clearnode-endpoint');
      webSocket.onopen = () => isConnected.value = true;
      webSocket.onclose = () => isConnected.value = false;
      webSocket.onerror = () => {
        isConnected.value = false;
        error.value = 'WebSocket connection error';
      };
    };
    
    // Main close function
    const closeChannel = async () => {
      // 1. Validate prerequisites
      if (!isConnected.value || !webSocket) {
        error.value = 'WebSocket not connected';
        return;
      }
      
      if (!channelId.value) {
        error.value = 'No channel ID found';
        return;
      }
      
      try {
        // 2. Set up UI state
        isClosing.value = true;
        error.value = null;
        success.value = false;
        
        // 3. Get wallet signer
        if (!window.ethereum) throw new Error('No Ethereum provider');
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();
        const address = await signer.getAddress();
        
        // 4. Create message signer function
        const messageSigner = async (payload) => {
          const message = JSON.stringify(payload);
          const digestHex = ethers.id(message);
          return await signer.signMessage(ethers.getBytes(digestHex));
        };
        
        // 5. Create and send close message
        const closeMessage = await createCloseChannelMessage(
          messageSigner,
          channelId.value,
          address // funds destination
        );
        const brokerState = await sendWebSocketRequest(closeMessage);
        
        // 6. Format final state and submit to client
        const finalStateData = {
          channelId: brokerState.channel_id,
          stateData: brokerState.state_data,
          version: brokerState.version,
          allocations: brokerState.allocations.map(alloc => ({
            destination: alloc.destination,
            token: alloc.token,
            amount: alloc.amount,
          })),
          serverSignature: brokerState.server_signature,
        };
        
        await window.nitroliteClient.closeChannel({
          stateData: brokerState.state_data,
          finalState: finalStateData,
        });
        
        // 7. Update state after success
        success.value = true;
        clearChannelData();
        
      } catch (err) {
        error.value = err.message || 'Close failed';
        console.error('Close error:', err);
      } finally {
        isClosing.value = false;
      }
    };
    
    // Send WebSocket request and handle response
    const sendWebSocketRequest = (payload) => {
      return new Promise((resolve, reject) => {
        const handleMessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            
            // Success response
            if (message.res && message.res[1] === 'close_channel') {
              webSocket.removeEventListener('message', handleMessage);
              resolve(message.res[2][0]); // Broker state
            }
            
            // Error response
            if (message.err) {
              webSocket.removeEventListener('message', handleMessage);
              reject(new Error(`${message.err[1]}: ${message.err[2]}`));
            }
          } catch (error) {
            console.error('Error parsing message:', error);
          }
        };
        
        // Setup listener with timeout
        webSocket.addEventListener('message', handleMessage);
        setTimeout(() => {
          webSocket.removeEventListener('message', handleMessage);
          reject(new Error('Close timeout'));
        }, 15000);
        
        webSocket.send(payload);
      });
    };
    
    return { 
      channelId, 
      isClosing, 
      error, 
      success, 
      isConnected, 
      closeChannel 
    };
  }
});
</script>

<style scoped>
.channel-close {
  padding: 20px;
  border: 1px solid #eee;
  border-radius: 8px;
  margin-bottom: 20px;
}
.active-channel {
  margin-bottom: 15px;
  padding: 10px;
  background-color: #f5f5f5;
  border-radius: 4px;
}
.error-message { color: #d32f2f; margin-top: 10px; }
.success-message { color: #388e3c; margin-top: 10px; }
.warning-message { color: #f57c00; margin-top: 10px; }
button {
  padding: 8px 16px;
  background-color: #1976d2;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
button:disabled { background-color: #bbdefb; cursor: not-allowed; }
</style>
```

  </TabItem>
</Tabs>

## Understanding Channel Closing Flow

When closing a channel with a ClearNode, the process involves these key steps:

1. **Creating a close request** using `createCloseChannelMessage` with the channel ID and funds destination
2. **Sending the close request** to the ClearNode via WebSocket
3. **Receiving final state** from the ClearNode with allocation information
4. **Processing the close** by calling the client's `closeChannel` method with the final state
5. **Cleaning up resources** by removing channel data from storage

## The Close Message Structure

The close channel message requires:

| Parameter | Description | Example |
|-----------|-------------|--------|
| `channelId` | Identifier for the channel to close | `"0x1234567890abcdef..."` |
| `fundDestination` | Address where remaining funds should go | `"0xUserAddress..."` |

## Broker Response Structure

The ClearNode's response contains a final state that includes:

| Component | Description | Example |
|-----------|-------------|--------|
| `channel_id` | Identifier for the channel | `"0x1234567890abcdef..."` |
| `state_data` | Encoded state data | `"0x000000..."` |
| `version` | Final state version number | `1` |
| `allocations` | Final token allocations | `[{destination, token, amount}]` |
| `server_signature` | Broker's signature | `{v, r, s}` values |

## Next Steps

After closing a channel, you should:

1. [Withdraw your funds](withdrawal) from the custody contract
2. [Set up a new channel](deposit_and_create_channel) if you want to continue transacting with the counterparty

## Closure Best Practices

- Always close all application sessions before closing the channel
- Ensure you have the latest agreed state with all signatures
- Back up the signed final state for your records
- Wait for sufficient block confirmations before considering the channel fully closed
- Verify the on-chain settlement matches your expected final balances

---

---
sidebar_position: 12
title: Withdrawal
description: Reclaim your funds from the custody contract that aren't locked in active channels.
keywords: [erc7824, nitrolite, withdrawal, state channels, custody contract, tokens]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Withdrawal

The `withdrawal` method allows you to withdraw tokens that were previously deposited into the custody contract but are not currently locked in active channels. This guide explains how to use this method to reclaim your available funds.

## Understanding Withdrawals in Nitrolite

In Nitrolite, your funds generally exist in two states:

1. **Locked in active channels**: Funds that are currently allocated to state channels
2. **Available in custody**: Funds that have been deposited but are not allocated to any channel

The `withdrawal` method specifically targets the second category - funds that are available in the custody contract but not locked in any active channel.

## Prerequisites for Withdrawal

Before attempting to withdraw funds, ensure:

1. You have a properly initialized client (see [Initializing Client](initializing_client))
2. You have non-zero available balance in the custody contract
3. Your wallet is connected and has enough ETH for gas fees

## Implementing Withdrawal

Here's how to implement withdrawals in different frameworks:

<Tabs>
  <TabItem value="react" label="React">

```javascript
import { useCallback } from 'react';

// Hook for handling withdrawals from the custody contract
export function useWithdrawal() {
  // Main withdrawal function
  const handleWithdrawal = useCallback(async () => {
    // 1. Check prerequisites
    if (!isConnected || !walletAddress || !client || !chainId) {
      console.error('Missing requirements: WebSocket, wallet, client, or chain');
      return { success: false, error: 'Connection prerequisites not met' };
    }

    setLoading(true);

    try {
      // 2. Verify available funds
      if (!accountInfo?.available || accountInfo.available <= 0n) {
        console.warn('No funds available to withdraw');
        return { success: false, error: 'No available funds' };
      }

      // 3. Execute withdrawal for all available funds
      const txHash = await client.withdrawal(accountInfo.available);

      // 4. Refresh account data
      await refreshAccountData();

      console.log('Withdrawal successful, transaction:', txHash);
      return { success: true, txHash };
    } catch (error) {
      console.error('Withdrawal failed:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      };
    } finally {
      setLoading(false);
    }
  }, [
    isConnected,
    walletAddress,
    client,
    accountInfo,
    chainId,
    refreshAccountData
  ]);

  // Function to withdraw a specific amount
  const withdrawSpecificAmount = useCallback(async (amount) => {
    if (!client) {
      return { success: false, error: 'Client not initialized' };
    }

    if (!amount || amount <= 0n) {
      return { success: false, error: 'Invalid amount' };
    }

    setLoading(true);

    try {
      // Ensure amount doesn't exceed available balance
      if (accountInfo?.available && amount > accountInfo.available) {
        return { 
          success: false, 
          error: 'Amount exceeds available balance' 
        };
      }

      // Execute withdrawal for specified amount
      const txHash = await client.withdrawal(amount);
      
      // Refresh account data
      await refreshAccountData();
      
      return { success: true, txHash };
    } catch (error) {
      console.error('Withdrawal failed:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      };
    } finally {
      setLoading(false);
    }
  }, [client, accountInfo, refreshAccountData]);

  return { handleWithdrawal, withdrawSpecificAmount };
}

// Usage example
async function exampleUsage() {
  const { handleWithdrawal } = useWithdrawal();
  const result = await handleWithdrawal();
  
  if (result.success) {
    console.log(`Withdrawal successful! Transaction: ${result.txHash}`);
  } else {
    console.error(`Withdrawal failed: ${result.error}`);
  }
}
```

  </TabItem>
  <TabItem value="nodejs" label="Node.js">

```javascript
import { ethers } from 'ethers';

/**
 * Withdraw funds from the custody contract
 * @param {object} client - Nitrolite client
 * @param {object} account - Account information containing available balance
 * @param {boolean} withdrawAll - Whether to withdraw all available funds
 * @param {bigint} amount - Optional specific amount to withdraw
 * @returns {Promise<object>} Result with transaction hash
 */
async function withdrawFunds(client, account, withdrawAll = true, amount = null) {
  try {
    // 1. Check prerequisites
    if (!client) {
      throw new Error('Client not initialized');
    }

    // 2. Check available balance
    if (!account || !account.available || account.available <= 0n) {
      console.warn('No funds available to withdraw');
      return { success: false, error: 'No available funds' };
    }

    let withdrawAmount;
    
    if (withdrawAll) {
      // Withdraw all available funds
      withdrawAmount = account.available;
    } else if (amount) {
      // Withdraw specific amount
      if (amount <= 0n) {
        return { success: false, error: 'Amount must be greater than 0' };
      }
      
      if (amount > account.available) {
        return { 
          success: false, 
          error: `Amount exceeds available balance (${amount} > ${account.available})` 
        };
      }
      
      withdrawAmount = amount;
    } else {
      return { success: false, error: 'Either withdrawAll or amount must be specified' };
    }

    console.log(`Withdrawing ${withdrawAmount} from custody contract...`);

    // 3. Execute withdrawal
    const txHash = await client.withdrawal(withdrawAmount);
    
    console.log(`Withdrawal successful! Transaction: ${txHash}`);
    return { success: true, txHash };
  } catch (error) {
    console.error('Withdrawal failed:', error);
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

// Usage example
async function main() {
  try {
    // Initialize client (simplified)
    const provider = new ethers.providers.JsonRpcProvider('https://ethereum-rpc-url');
    const wallet = new ethers.Wallet('your-private-key', provider);
    const client = await initializeClient(wallet, provider);
    
    // Get account information
    const accountInfo = await client.getAccountInfo();
    console.log(`Available balance: ${accountInfo.available}`);
    
    // Withdraw all funds
    const result = await withdrawFunds(client, accountInfo, true);
    
    if (result.success) {
      console.log(`Withdrawal complete! Transaction: ${result.txHash}`);
    } else {
      console.error(`Withdrawal failed: ${result.error}`);
    }
  } catch (error) {
    console.error('Error in main function:', error);
  }
}
```

  </TabItem>
  <TabItem value="angular" label="Angular">

```typescript
// withdrawal.service.ts
import { Injectable } from '@angular/core';
import { Observable, from } from 'rxjs';
import { catchError, map } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class WithdrawalService {
  constructor() {}
  
  /**
   * Withdraw all available funds from custody contract
   */
  public withdrawAllFunds(client: any, accountInfo: any): Observable<any> {
    // Validate inputs
    if (!client || !accountInfo) {
      return from(Promise.resolve({
        success: false,
        error: 'Client or account info not provided'
      }));
    }
    
    if (!accountInfo.available || accountInfo.available <= 0n) {
      return from(Promise.resolve({
        success: false,
        error: 'No available funds to withdraw'
      }));
    }
    
    return from(this.executeWithdrawal(client, accountInfo.available)).pipe(
      map(txHash => ({
        success: true,
        txHash
      })),
      catchError(error => {
        console.error('Withdrawal failed:', error);
        return from([{
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        }]);
      })
    );
  }
  
  /**
   * Withdraw a specific amount of funds
   */
  public withdrawAmount(client: any, accountInfo: any, amount: bigint): Observable<any> {
    // Validate inputs
    if (!client) {
      return from(Promise.resolve({
        success: false,
        error: 'Client not provided'
      }));
    }
    
    if (!amount || amount <= 0n) {
      return from(Promise.resolve({
        success: false,
        error: 'Invalid withdrawal amount'
      }));
    }
    
    if (!accountInfo?.available || amount > accountInfo.available) {
      return from(Promise.resolve({
        success: false,
        error: 'Amount exceeds available balance'
      }));
    }
    
    return from(this.executeWithdrawal(client, amount)).pipe(
      map(txHash => ({
        success: true,
        txHash
      })),
      catchError(error => {
        console.error('Withdrawal failed:', error);
        return from([{
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        }]);
      })
    );
  }
  
  /**
   * Execute withdrawal transaction
   */
  private async executeWithdrawal(client: any, amount: bigint): Promise<string> {
    try {
      return await client.withdrawal(amount);
    } catch (error) {
      console.error('Error executing withdrawal:', error);
      throw error;
    }
  }
}

// Usage example
async function withdrawUsingService() {
  // Get service and client instances
  const service = new WithdrawalService();
  const client = getClient(); // Your nitrolite client
  
  // Get account information
  const accountInfo = await client.getAccountInfo();
  
  if (accountInfo.available > 0n) {
    // Withdraw all available funds
    service.withdrawAllFunds(client, accountInfo).subscribe({
      next: (result) => {
        if (result.success) {
          console.log(`Withdrawal successful: ${result.txHash}`);
        } else {
          console.error(`Withdrawal failed: ${result.error}`);
        }
      }
    });
  }
}
```

  </TabItem>
  <TabItem value="vue" label="Vue.js">

```javascript
import { defineComponent } from 'vue';

/**
 * Withdrawal functionality for Vue.js applications
 * Can be used in a component's setup() method
 */
export function useWithdrawal(client) {
  /**
   * Withdraw all available funds from the custody contract
   * @param {object} accountInfo - The account information containing available balance
   * @returns {Promise<object>} Result with transaction hash or error
   */
  const withdrawAllFunds = async (accountInfo) => {
    // 1. Validate requirements
    if (!client) {
      return { success: false, error: 'Client not initialized' };
    }

    if (!accountInfo?.available || accountInfo.available <= 0n) {
      return { success: false, error: 'No available funds to withdraw' };
    }

    try {
      // 2. Execute withdrawal for all available funds
      const txHash = await client.withdrawal(accountInfo.available);
      return { success: true, txHash };
    } catch (err) {
      console.error('Withdrawal failed:', err);
      return { 
        success: false, 
        error: err instanceof Error ? err.message : 'Unknown error' 
      };
    }
  };

  /**
   * Withdraw a specific amount of funds
   * @param {object} accountInfo - The account information containing available balance
   * @param {bigint} amount - The specific amount to withdraw
   * @returns {Promise<object>} Result with transaction hash or error
   */
  const withdrawSpecificAmount = async (accountInfo, amount) => {
    // 1. Validate requirements
    if (!client) {
      return { success: false, error: 'Client not initialized' };
    }

    if (!amount || amount <= 0n) {
      return { success: false, error: 'Invalid withdrawal amount' };
    }

    if (!accountInfo?.available || amount > accountInfo.available) {
      return { 
        success: false, 
        error: 'Amount exceeds available balance' 
      };
    }

    try {
      // 2. Execute withdrawal for specified amount
      const txHash = await client.withdrawal(amount);
      return { success: true, txHash };
    } catch (err) {
      console.error('Withdrawal failed:', err);
      return { 
        success: false, 
        error: err instanceof Error ? err.message : 'Unknown error' 
      };
    }
  };

  // Format a bigint amount to a human-readable string (assumes 6 decimals like USDC)
  const formatAmount = (amount) => {
    if (!amount) return '0';
    return (Number(amount) / 1e6).toFixed(6);
  };

  return {
    withdrawAllFunds,
    withdrawSpecificAmount,
    formatAmount
  };
}

// Usage example
async function withdrawExample() {
  // Assuming client is initialized elsewhere
  const { withdrawAllFunds, withdrawSpecificAmount } = useWithdrawal(client);
  
  // Get account information
  const accountInfo = await client.getAccountInfo();
  console.log(`Available balance: ${(Number(accountInfo.available) / 1e6).toFixed(6)}`);
  
  // Withdraw all available funds
  const result = await withdrawAllFunds(accountInfo);
  
  if (result.success) {
    console.log(`Withdrawal successful! Transaction: ${result.txHash}`);
  } else {
    console.error(`Withdrawal failed: ${result.error}`);
  }
}
```

  </TabItem>
</Tabs>

## Understanding Withdrawals

When withdrawing funds from the custody contract, here's what happens:

1. **Check available balance**: The system verifies you have sufficient available (unlocked) funds
2. **Create and submit transaction**: Your client submits a transaction to the custody contract
3. **Wait for confirmation**: The blockchain processes the transaction
4. **Receive funds**: Tokens are sent back to your wallet address

## Withdrawal Parameters

The withdrawal method takes a single parameter:

| Parameter | Type | Description | Example |
|-----------|------|-------------|--------|
| `amount` | bigint | Amount of tokens to withdraw (in smallest unit) | `1000000n` (for 1 USDC with 6 decimals) |

## Common Withdrawal Scenarios

| Scenario | Description | Implementation |
|----------|-------------|---------------|
| **Withdraw all** | Withdraw entire available balance | `client.withdrawal(accountInfo.available)` |
| **Partial withdrawal** | Withdraw specific amount | `client.withdrawal(1000000n)` |
| **After channel closure** | Withdraw funds after closing channels | First close channel, then withdraw |

## Handling Available vs. Locked Funds

It's important to understand that:

1. You can only withdraw **available** funds, not those locked in active channels
2. To withdraw locked funds, you must first close the respective channels
3. The `accountInfo` object contains both `available` and `locked` balances

```javascript
const accountInfo = await client.getAccountInfo();
console.log(`Available: ${accountInfo.available}`);

// Can only withdraw the available amount
if (accountInfo.available > 0n) {
  await client.withdrawal(accountInfo.available);
}
```

## Best Practices

When implementing withdrawals, follow these best practices:

1. **Always check available balance** before attempting withdrawal
2. **Handle transaction errors** gracefully, with proper user feedback
3. **Refresh account data** after successful withdrawal
4. **Provide transaction hash** to users for tracking purposes
5. **Consider gas costs** which are paid separately from the withdrawal amount

---

---
sidebar_position: 1
title: Quick Start
description: Learn how to use Nitrolite state channels from start to finish.
keywords: [erc7824, nitrolite, state channels, quick start, tutorial]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Quick Start

**[Nitrolite](https://www.npmjs.com/package/@erc7824/nitrolite)** is our official SDK for creating state channel applications. It provides a comprehensive set of functions and types to simplify the development of high-performance blockchain applications.

## Prerequisites

Before you begin working with Nitrolite, ensure that you have:

- **Node.js**: Version 16 or later
- **Package Manager**: npm, yarn, or pnpm
- **Web3 Development Knowledge**: Basic understanding of Ethereum and smart contracts
- **Development Environment**: 
  - For frontend: React, Vue, or similar framework
  - For backend: Node.js environment
- **Ethereum Wallet**: MetaMask or another web3 provider for testing
- **Test Assets**: For test networks

## Installation

You can install Nitrolite using your preferred package manager:

<Tabs>
  <TabItem value="npm" label="npm">

  ```bash
  npm install @erc7824/nitrolite
  ```

  </TabItem>
  <TabItem value="yarn" label="yarn">

  ```bash
  yarn add @erc7824/nitrolite
  ```

  </TabItem>
  <TabItem value="pnpm" label="pnpm">

  ```bash
  pnpm add @erc7824/nitrolite
  ```

  </TabItem>
</Tabs>

Once installed, you can import Nitrolite into your project:

```javascript
// ES Modules
import { NitroliteClient } from '@erc7824/nitrolite';

// CommonJS
const { NitroliteClient } = require('@erc7824/nitrolite');
```

## Build with AI
We have generated a [llms-full.txt](https://erc7824.org/llms-full.txt) file that converts all our documentation into a single markdown document following the https://llmstxt.org/ standard.



## Next steps

Channels follow a clear lifecycle that involves several key steps:

1. **[Client Initialization](initializing_client)**: Set up the client with your desired configuration
2. **[Deposit and Channel Creation](deposit_and_create_channel)**: Fund your channel and establish it with participants
3. **[ClearNode Connection](connect_to_the_clearnode)**: Connect to a ClearNode for off-chain messaging
4. **[Channel Asset Management](balances)**: Monitor and manage assets within your channels
5. **[Application Sessions](application_session)**: Create sessions to run specific applications
6. **[Session Closure](close_session)**: Properly close application sessions when finished
7. **[Resize Operations](resize_channel)**: Adjust channel capacity as needed
8. **[Channel Closure](close_channel)**: Safely close channels with final state settlement
9. **[Withdrawal](withdrawal)**: Reclaim your funds from the custody contract

We recommend working through these guides in sequence to understand the complete channel workflow. Each guide builds on concepts from previous sections.

Start with the [Client Initialization](initializing_client) guide to begin your journey with Nitrolite state channels.